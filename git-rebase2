#!/usr/bin/env perl

use strict;

use Data::Dumper;
use Carp;
use File::Path qw(rmtree);
use File::Temp qw(:mktemp);

sub main ($) { my @argv = @{$_[0]};
    my $interactive = 0;
    while (1) {
        if (0) {
        } elsif ($argv[0] eq "-i" || $argv[0] eq "--interactive") {
            $interactive = 1;
            shift @argv;
        } elsif ($argv[0] eq "--abort") {
            confess ("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. -1]) . "\"") if (scalar @argv > 1);
            abort_rebase();
            return;
        } elsif ($argv[0] eq "--skip") {
            confess ("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. -1]) . "\"") if (scalar @argv > 1);
            my ($todo, $current, $commits, $target_ref) = restore_rebase();
            print Dumper($todo, $current, $commits, $target_ref);
            if ($current) {
                run_command("git reset --hard HEAD");
                unlink(".git/rebase2/current");
            }
            run_rebase($todo, $commits, $target_ref);
            return;
        } elsif ($argv[0] eq "--continue") {
            confess ("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. -1]) . "\"") if (scalar @argv > 1);
            my ($todo, $current, $commits, $target_ref) = restore_rebase();
            print Dumper($todo, $current, $commits, $target_ref);
            if ($current) {
                run_continue($current, $commits);
                unlink(".git/rebase2/current");
            }
            run_rebase($todo, $commits, $target_ref);
            return;
        # } elsif (scalar @argv == 1) { TODO: find HEAD?
        } elsif (scalar @argv == 2) {
            my ($dest, $source_to) = @argv;
            my ($todo, $commits, $target_ref) = init_rebase($dest, $source_to);
            if ($interactive) {
                ($todo, $commits) = edit_todo($todo);
            }
            run_rebase($todo, $commits, $target_ref);
            return;
        } else {
            confess ("Invalid arguments: \"" . join(" ", @argv) . "\"");
        }
    }
}

sub restore_rebase() {
    my $target_ref = read_file(".git/rebase2/target_ref");
    my ($todo, $commits) = read_todo(".git/rebase2/todo");
    my $current = 0;
    if (-e ".git/rebase2/current") {
        my @current_todo = read_todo(".git/rebase2/current");
        print Dumper(\@current_todo);
        $current = get_single($current_todo[0]);
    }
    return ($todo, $current, $commits, $target_ref);
}

sub init_rebase($$) { my ($dest, $source_to) = @_;
    my $target_ref = $source_to;
    my $source_from = git_merge_base($dest, $source_to);
    #print Dumper($dest, $source_from, $source_to, $target_ref);
    #TODO: resolve all arguments
    my ($dest_hash, $source_to_hash) = git_resolve_hashes([$dest, $source_to]);
    my $commits = git_fetch_commits($source_from, $source_to);
    my $todo = build_rebase_sequence($commits, $source_to_hash);
    init_save($target_ref);
    # TODO: edit if interactive
    run_command("git checkout --quiet --detach $dest_hash");
    return ($todo, $commits, $target_ref);
}

sub edit_todo($$) { my ($old_todo, $old_commits) = @_;
    my ($tmpfh, $tmpname) = mkstemp(".git/rebase2/todo.XXXXXXXX");
    # TODO: write without reopen, to fh
    close($tmpfh) or confess ("Unable to close the tmpfile");
    save_todo($old_todo, $tmpname, $old_commits);
    print "saved\n";
    run_command("editor $tmpname");
    print "edited\n";
    my ($new_todo, $new_commits) = read_todo($tmpname);
    print Dumper($new_todo, $new_commits);
    return ($new_todo, $new_commits);
}

sub run_continue($$) { my ($current, $commits) = @_;
    run_command("git rev-parse --verify HEAD >/dev/null"
                . " && git update-index --ignore-submodules --refresh"
                . " && git diff-files --quiet --ignore-submodules");
    print Dumper($current);
    # TODO: restore proper rebase-like behavior
    if ($current->{type} eq "pick") {
        if (system("git diff-index --quiet --ignore-submodules --cached HEAD") == 0) {
            # commited already
        } else {
            run_command("git commit -c $current->{ahash}");
        }
    } else {
        confess "Type $current->{type} is unknown or not implemented";
    }
}

sub run_rebase($$$) { my ($todo, $commits, $target_ref) = @_;
    # TODO: handle errors
    while (defined (my $current = shift @{$todo})) {
        save_todo($todo, ".git/rebase2/todo", $commits);
        save_todo([$current], ".git/rebase2/current", $commits);
        run_step($current, $commits);
        unlink(".git/rebase2/current");
    }
    # TODO: make proper reflog
    run_command("git checkout -B $target_ref");
    cleanup_save();
}

sub abort_rebase() {
    my $target_ref = read_file(".git/rebase2/target_ref");
    run_command("git reset --hard $target_ref");
    run_command("git checkout -f $target_ref");
    cleanup_save();
}

sub run_step($) { my ($rebase_step, $commits) = @_;
    if ($rebase_step->{type} eq "pick") {
        print "Apply: $commits->{by_hash}->{$rebase_step->{ahash}}->{subject}\n";
        pick($rebase_step->{ahash});
    } else {
        confess "Type $rebase_step->{type} is unknown or not implemented";
    }
}

sub pick($) { my ($hash) = @_;
    # TODO: clear out all details
    run_command("git cherry-pick --allow-empty --allow-empty-message --ff $hash");
}

sub build_rebase_sequence($$) { my ($commits, $top_hash) = @_;
    confess("Invalid top hash: $top_hash") unless (exists $commits->{by_hash}->{$top_hash});
    my @result = ();
    my $hash = $top_hash;
    do {
        push @result, {type => 'pick', ahash => $commits->{by_hash}->{$hash}->{ahash}};
        my $parents = $commits->{by_hash}->{$hash}->{parents};
        confess("Multiple parents for $hash") unless ($#{$parents} == 0);
        $hash = $parents->[0];
    } while (exists $commits->{by_hash}->{$hash}); # TODO: use bottom_hash instead
    @result = reverse @result;
    return \@result;
}

sub git_resolve_hashes($) { my ($refs) = @_;
    foreach (@{$refs}) { verify_cmdarg($_); }
    my $refs_str = join " ", @{$refs};
    my @result = ();
    iterate_popen("git rev-parse $refs_str", sub {
        s/^\s+|\s+$//g;
        push @result, $_;
    });
    confess("Hash number does not match") unless ($#result == $#{$refs});
    return @result;
}

sub git_fetch_commits($$) { my ($from, $to) = @_;
    verify_cmdarg($from);
    verify_cmdarg($to);
    my $commits = {by_hash => {}, by_ahash => {}};
    # TODO: abbreviated hashes should really be used some day,
    # but this needs care
    # looks like git dynamically decides length for each hash,
    # so probably need indexing rather than just substring.
    # Or do it other way around? Don't know...
    iterate_popen("git log --ancestry-path --pretty=format:%H:%h:%P:%s $from..$to",
                  sub {
        if (/^([0-9a-f]+):([0-9a-f]+):([0-9a-f ]*):(.*)\x{a}?$/) {
            my $hash = $1;
            my $ahash = $2;
            my @parents = split(/ /, $3);
            my $subject = $4;
            verify_hash($hash);
            foreach my $p (@parents) { verify_hash($p); }
            if (exists $commits->{by_hash}->{$hash} || exists $commits->{by_ahash}->{$ahash}) {
                confess "Duplicated commit: $hash ($ahash)";
            }
            my $obj = {parents => \@parents, subject => $subject, hash => $hash, ahash => $ahash};
            $commits->{by_hash}->{$hash} = $obj;
            $commits->{by_ahash}->{$ahash} = $obj;
        } else {
            confess("Could not parse line: $_");
        }
    });
    return $commits;
}

sub git_merge_base($$) { my ($b1, $b2) = @_;
    verify_cmdarg($b1);
    verify_cmdarg($b2);
    my $result = "";
    my $hit = 0;
    iterate_popen("git merge-base -a $b1 $b2", sub {
        s/^\s+|\s+$//g;
        if (!$hit) {
            $result = $_;
            $hit = 1;
        } else {
            confess "Multiple merge-bases for $b1 and $b2";
        }
    });
    if (!$hit) {
        confess "Merge-base not found for $b1 and $b2"
    }
    return $result;
}

sub git_sequence_editor() {
    # TODO copy the git_sequence_editor here
    return "editor";
}

sub run_command($) { my ($command) = @_;
    my $ret = system($command);
    confess("Command failed: $ret") unless ($ret == 0);
}

sub iterate_popen($$) { my ($command, $code) = @_;
    open(my $in, "-|", $command) or confess "Cannot start a program: $!";
    while (<$in>) {
        $code->($_);
    }
    close ($in) or confess "Program failed";
}

sub verify_hash($) { my ($str) = @_;
    # allow abbreviated
    if ($str !~ /^[0-9a-f]{40}$/) {
        confess "Invalid hash: $str";
    }
}

sub verify_cmdarg($) { my ($str) = @_;
    if ($str =~ /["'\\\(\)#]|[\x00- ]/) {
        confess "Invalid cmdarg: $str";
    }
}

sub init_save($) { my ($target_ref) = @_;
    if (-e ".git/rebase2") {
        confess "already in progress?";
    }
    mkdir(".git/rebase2") or confess "Mkdir .git/rebase2 failed: $!";
    write_file(".git/rebase2/target_ref", $target_ref);
}

sub cleanup_save() {
    # will throw itself
    rmtree(".git/rebase2");
}

sub save_todo($$$) { my ($todo, $file, $commits) = @_;
    with_output_file($file, sub { my ($out) = @_;
        foreach my $step (@{$todo}) {
            if ($step->{type} eq "pick") {
                print $out "pick $step->{ahash} $commits->{by_ahash}->{$step->{ahash}}->{subject}\n";
            } else {
                confess "Type $step->{type} is unknown or not implemented";
            }
        }
    });
}

sub read_todo($) { my ($filename) = @_;
    my $todo = [];
    my $commits = {by_ahash => {}};
    open(my $in, "<", $filename) or confess "Cannot open file $filename: $!";
    while (<$in>) {
        if (/^#.*$/) {
        } elsif (/^pick ([0-9a-f]+) (.*)$/) {
            push @{$todo}, {type => "pick", ahash => $1};
            if (!exists $commits->{by_ahash}->{$1}) {
                # duplicates are in principle acceptable
                $commits->{by_ahash}->{$1} = {subject => $2};
            }
        } elsif (/^[[:space:]]*$/) {
        } else {
            confess "Unrecognised todo line: \"$_\"";
        }
    }
    return ($todo, $commits);
}

sub with_output_file($$) { my ($filename, $proc) = @_;
    open(my $out, ">", $filename + ".new") or confess "Cannot open file $filename.new: $!";
    $proc->($out);
    close($out) or confess "Cannot close output file $filename.new: $!";
    rename($filename + ".new", $filename) or "Cannot replace output file $filename: $!";
}

sub write_file($$) { my ($filename, $str) = @_;
    with_output_file($filename, sub { my ($out) = @_;
        print $out $str;
    });
}

sub read_file($) { my ($filename) = @_;
    open(my $out, "<", $filename) or confess "Cannot open file $filename: $!";
    my $data = "";
    if (read($out, $data, 1024) <= 0) {
        confess "Read failed: $!";
    }
    close($out) or confess "Cannot close file $filename: $!";
    return $data;
}

sub get_single(\@) { my ($array) = @_;
    if (scalar @{$array} != 1) {
        confess ("Should be an array with single element: " . Dumper($array));
    }
    return $array->[0];
}

# TODO: options parser
# * interactive
# * continue, abort
main(\@ARGV);
