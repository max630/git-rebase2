#!/usr/bin/env perl

use strict;

use Data::Dumper;
use Carp;
use File::Path qw(rmtree);

# TODO:
# * Implement --continue, --abort, --skip
#  * Maintanting of todo and current (+)
#  * Preparation of working directory (+)
#  * --abort
#  * --continue
#  * Short hashes
#  * Option parsing
#  * ensuring that there is no rebase in progress
#  * Prototype ready here
#  * Learn exactly how it works in current rebase:
#   * detection of unresolved changes
#   * detection of uncommited changes
#   * detection of commited pick

sub main ($$) { my ($dest, $source_to) = @_;
    my ($todo, $commits, $target_ref) = init_rebase($dest, $source_to);
    run_rebase($todo, $commits, $target_ref);
}

sub init_rebase($$) { my ($dest, $source_to) = @_;
    my $target_ref = $source_to;
    my $source_from = git_merge_base($dest, $source_to);
    #print Dumper($dest, $source_from, $source_to, $target_ref);
    #TODO: resolve all arguments
    my ($dest_hash, $source_to_hash) = git_resolve_hashes([$dest, $source_to]);
    my $commits = git_fetch_commits($source_from, $source_to);
    my $todo = build_rebase_sequence($commits, $source_to_hash);
    init_save($target_ref);
    # TODO: edit if interactive
    run_command("git checkout --quiet --detach $dest_hash");
    return ($todo, $commits, $target_ref);
}

sub run_rebase($$$) { my ($todo, $commits, $target_ref) = @_;
    # TODO: handle errors
    while (defined (my $current = shift @{$todo})) {
        save_todo($todo, ".git/rebase2/todo", $commits);
        save_todo([$current], ".git/rebase2/current", $commits);
        run_step($current, $commits);
        unlink(".git/rebase2/current");
    }
    # TODO: make proper reflog
    run_command("git checkout -B $target_ref");
    cleanup_save();
}

sub run_step($) { my ($rebase_step, $commits) = @_;
    if ($rebase_step->{type} eq "pick") {
        print "Apply: $commits->{$rebase_step->{hash}}->{subject}\n";
        pick($rebase_step->{hash});
    } else {
        confess "Type $rebase_step->{type} is unknown or not implemented";
    }
}

sub pick($) { my ($hash) = @_;
    # TODO: clear out all details
    run_command("git cherry-pick --allow-empty --allow-empty-message --ff $hash");
}

sub build_rebase_sequence($$) { my ($commits, $top_hash) = @_;
    confess("Invalid top hash: $top_hash") unless (exists $commits->{$top_hash});
    my @result = ();
    my $hash = $top_hash;
    do {
        push @result, {type => 'pick', hash => $hash};
        my $parents = $commits->{$hash}->{parents};
        confess("Multiple parents for $hash") unless ($#{$parents} == 0);
        $hash = $parents->[0];
    } while (exists $commits->{$hash}); # TODO: use bottom_hash instead
    @result = reverse @result;
    return \@result;
}

sub git_resolve_hashes($) { my ($refs) = @_;
    foreach (@{$refs}) { verify_cmdarg($_); }
    my $refs_str = join " ", @{$refs};
    my @result = ();
    iterate_popen("git rev-parse $refs_str", sub {
        s/^\s+|\s+$//g;
        push @result, $_;
    });
    confess("Hash number does not match") unless ($#result == $#{$refs});
    return @result;
}

sub git_fetch_commits($$) { my ($from, $to) = @_;
    verify_cmdarg($from);
    verify_cmdarg($to);
    my $commits = {};
    # TODO: abbreviated hashes should really be used some day,
    # but this needs care
    # looks like git dynamically decides length for each hash,
    # so probably need indexing rather than just substring.
    # Or do it other way around? Don't know...
    iterate_popen("git log --ancestry-path --pretty=format:%H:%P:%s $from..$to",
                  sub {
        if (/^([0-9a-f]+):([0-9a-f ]*):(.*)\x{a}?$/) {
            my $hash = $1;
            my @parents = split(/ /, $2);
            my $subject = $3;
            verify_hash($hash);
            foreach my $p (@parents) { verify_hash($p); }
            if (exists $commits->{$hash}) {
                confess "Duplicated commit: $hash";
            }
            $commits->{$hash} = {parents => \@parents, subject => $subject};
        } else {
            confess("Could not parse line: $_");
        }
    });
    return $commits;
}

sub git_merge_base($$) { my ($b1, $b2) = @_;
    verify_cmdarg($b1);
    verify_cmdarg($b2);
    my $result = "";
    my $hit = 0;
    iterate_popen("git merge-base -a $b1 $b2", sub {
        s/^\s+|\s+$//g;
        if (!$hit) {
            $result = $_;
            $hit = 1;
        } else {
            confess "Multiple merge-bases for $b1 and $b2";
        }
    });
    if (!$hit) {
        confess "Merge-base not found for $b1 and $b2"
    }
    return $result;
}

sub run_command($) { my ($command) = @_;
    my $ret = system($command);
    confess("Command failed: $ret") unless ($ret == 0);
}

sub iterate_popen($$) { my ($command, $code) = @_;
    open(my $in, "-|", $command) or confess "Cannot start a program: $!";
    while (<$in>) {
        $code->($_);
    }
    close ($in) or confess "Program failed";
}

sub verify_hash($) { my ($str) = @_;
    # allow abbreviated
    if ($str !~ /^[0-9a-f]{40}$/) {
        confess "Invalid hash: $str";
    }
}

sub verify_cmdarg($) { my ($str) = @_;
    if ($str =~ /["'\\\(\)#]|[\x00- ]/) {
        confess "Invalid cmdarg: $str";
    }
}

sub init_save($) { my ($target_ref) = @_;
    if (-e ".git/rebase2") {
        confess "already in progress?";
    }
    mkdir(".git/rebase2") or confess "Mkdir .git/rebase2 failed: $!";
    write_file(".git/rebase2/target_ref", $target_ref);
}

sub cleanup_save() {
    # will throw itself
    rmtree(".git/rebase2");
}

sub save_todo($$$) { my ($todo, $file, $commits) = @_;
    with_output_file(".git/rebase2/todo", sub { my ($out) = @_;
        foreach my $step (@{$todo}) {
            if ($step->{type} eq "pick") {
                print $out "pick $step->{hash} $commits->{$step->{hash}}->{subject}\n";
            } else {
                confess "Type $step->{type} is unknown or not implemented";
            }
        }
    });
}

sub with_output_file($$) { my ($filename, $proc) = @_;
    open(my $out, ">", $filename + ".new") or confess "Cannot open file $filename.new: $!";
    $proc->($out);
    close($out) or confess "Cannot close output file $filename.new: $!";
    rename($filename + ".new", $filename) or "Cannot replace output file $filename: $!";
}

sub write_file($$) { my ($filename, $str) = @_;
    with_output_file($filename, sub { my ($out) = @_;
        print $out $str;
    });
}

# TODO: options parser
# * interactive
# * continue, abort
main($ARGV[0], $ARGV[1]);
