#!/usr/bin/env perl

use strict;

use Data::Dumper;
use Carp;

sub main ($$) { my ($dest, $source_to) = @_;
    my $target_ref = $source_to;
    my $source_from = git_merge_base($dest, $source_to);
    #print Dumper($dest, $source_from, $source_to, $target_ref);
    #TODO: resolve all arguments
    my ($commits, $top_hash) = git_fetch_commits($source_from, $source_to);
    print Dumper(build_rebase_sequence($commits, $top_hash));
    # combine sequence
    # edit
    # perform sequence
}

sub build_rebase_sequence($$) { my ($commits, $top_hash) = @_;
    confess("Invalid top hash: $top_hash") unless (exists $commits->{$top_hash});
    my @result = ();
    my $hash = $top_hash;
    do {
        push @result, {type => 'pick', hash => $hash};
        my $parents = $commits->{$hash}->{parents};
        confess("Multiple parents for $hash") unless ($#{$parents} == 0);
        $hash = $parents->[0];
    } while (exists $commits->{$hash}); # TODO: use bottom_hash instead
    @result = reverse @result;
    return \@result;
}

sub git_fetch_commits($$) { my ($from, $to) = @_;
    verify_cmdarg($from);
    verify_cmdarg($to);
    my $commits = {};
    my $buffer = "";
    my $top_hash = "";
    iterate_popen("git log --ancestry-path --pretty=format:%H%x00%P%x00%B%x00 $from..$to",
                  sub {
        $buffer = $buffer . $_;
        if ($buffer =~ /^([^\x00]*)\x00([^\x00]*)\x00([^\x00]*)\x00\x{a}?(.*)$/s) {
            my $hash = $1;
            my @parents = split(/ /, $2);
            my $comment = $3;
            $buffer = $4;
            verify_hash($hash);
            foreach my $p (@parents) { verify_hash($p); }
            if ($top_hash eq "") {
                $top_hash = $hash;
            }
            if (exists $commits->{$hash}) {
                confess "Duplicated commit: $hash";
            }
            $commits->{$hash} = {parents => \@parents, comment => $comment};
        }
    });
    if ($buffer ne "") {
        confess "Leftover buffer: $buffer";
    }
    return ($commits, $top_hash);
}

sub git_merge_base($$) { my ($b1, $b2) = @_;
    verify_cmdarg($b1);
    verify_cmdarg($b2);
    my $result = "";
    my $hit = 0;
    iterate_popen("git merge-base -a $b1 $b2", sub {
        s/^\s+|\s+$//g;
        if (!$hit) {
            $result = $_;
            $hit = 1;
        } else {
            confess "Multiple merge-bases for $b1 and $b2";
        }
    });
    if (!$hit) {
        confess "Merge-base not found for $b1 and $b2"
    }
    return $result;
}

sub iterate_popen($$) { my ($command, $code) = @_;
    open(my $in, "-|", $command) or confess "Cannot start a program: $!";
    while (<$in>) {
        $code->($_);
    }
    close ($in) or confess "Program failed";
}

sub verify_hash($) { my ($str) = @_;
    if ($str !~ /^[0-9a-f]{40}$/) {
        confess "Invalid hash: $str";
    }
}

sub verify_cmdarg($) { my ($str) = @_;
    if ($str =~ /["'\\\(\)#]|[\x00- ]/) {
        confess "Invalid cmdarg: $str";
    }
}

main($ARGV[0], $ARGV[1]);
