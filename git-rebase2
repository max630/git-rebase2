#!/usr/bin/env perl

# vim: foldmethod=marker

use strict;

use Data::Dumper;
use Carp;
use File::Path qw(rmtree);
use File::Temp qw(:mktemp);

my $GIT_DIR = read_popen("git rev-parse --git-dir");
# full list of invalid sylbols is unclear.
# definitely no \ or " (to be used in command-line), what else?
# be safe here
if ($GIT_DIR !~ /^[-a-z0-9_\.,\/ ]+$/i) {
    confess("Some unsupported symbols in: $GIT_DIR");
}

# {{{ utils

sub retry (&$) { my ($code, $ok) = @_;
    my $warray = wantarray;
    while (1) {
        my $result;
        my @result;
        if ($warray) {
            @result = eval { $code->(); }
        } else {
            $result = eval { $code->(); }
        }
        if ($@ ne "") {
            print "Error: $@";
            print "Retry (y/N)?";
            my $answer = <STDIN>;
            if ($answer !~ /^y.*/i) {
                ${$ok} = 0;
                return;
            }
        } else {
            ${$ok} = 1;
            if ($warray) {
                return @result;
            } else {
                return $result;
            }
        }
    }
}

# }}}

# {{{ io utils

sub iterate_popen(&$) { my ($code, $command) = @_;
    open(my $in, "-|", $command) or confess "Cannot start a program: $!";
    while (<$in>) {
        $code->($_);
    }
    close ($in) or confess "Program failed";
}

# }}}

# {{{ git utils

sub git_no_uncommitted_changes()
{
    return (system("git diff-index --quiet --ignore-submodules HEAD") == 0);
}

sub git_verify_clean()
{
    confess "Not clean working directory" unless git_no_uncommitted_changes();
    confess "git-am or rebase in progress" if -e "$GIT_DIR/rebase-apply";
    confess "rebase in progress" if -e "$GIT_DIR/rebase-merge";
}

# }}}

# {{{ DOC: Types
#
# $commits = {
#   refs => { $ref => $hash },
#   by_hash => { $hash => Entry },
# }
# ref is ahash or symbolic ref
#
# Entry is {
#   ahash => String,
#   hash => String[40],
#   subject => String,
#   parent => [String[40]],
# }
#
# $todo = [ Step ]
#
# Step is {
#   type => String,
#   ...
# } is {
#   type => one of("pick", "fixup", "edit"),
#   ahash => String
# } or {
#   type => "exec",
#   command => String
# } or {
#   type => "comment",
#   comment => String
# } or {
#   type => "merge",
#   comment => String,
#   parents => [String],
#   flags => {
#       (optional) ours => Int
#   }
# }
#
# }}}

sub main($) { my ($argv) = @_;
    my $parsed = parse_cli($argv);
    if (0) {
    } elsif ($parsed->[0] eq "ABORT") {
        abort_rebase();
    } elsif ($parsed->[0] eq "CONTINUE") {
        my ($todo, $current, $commits, $target_ref) = restore_rebase();
        if ($current) {
            run_continue($current, $commits);
            unlink("$GIT_DIR/rebase2/current");
        }
        run_rebase($todo, $commits, $target_ref);
    } elsif ($parsed->[0] eq "SKIP") {
        my ($todo, $current, $commits, $target_ref) = restore_rebase();
        if ($current) {
            run_command("git reset --hard HEAD");
            unlink("$GIT_DIR/rebase2/current");
        }
        run_rebase($todo, $commits, $target_ref);
    } elsif ($parsed->[0] eq "RUN") {
        my ($tag, $dest, $source_to, $onto, $through, $interactive) = @{$parsed};
        git_verify_clean();
        $target = undef;
        if (defined $source_to) {
            $target = $source_to;
        } else {
            my $head_path = read_popen("git symbolic-ref -q HEAD");
            if ($head_path =~ /refs\/heads\/(.*)/) {
                $target = $1;
            } else {
                confess("Unsupported ref checked-out: $head_path");
            }
        }
        main_run($dest, $target, $onto, $through, $interactive);
    } else {
        confess("Unexpected: " . Data::Dumper($parsed));
    }
}

sub parse_cli($) { my @argv = @{$_[0]};
    my $interactive = 0;
    my $onto = undef;
    my @through;
    while (1) {
        if (0) {
        } elsif ($argv[0] eq "-i" || $argv[0] eq "--interactive") {
            $interactive = 1;
            shift @argv;
        } elsif ($argv[0] eq "--through") {
            push @through, $argv[1];
            shift @argv;
            shift @argv;
        } elsif ($argv[0] eq "--onto") {
            confess("--onto doubled") if (defined $onto);
            my $onto_val = $argv[1];
            $onto = \$onto_val;
            shift @argv;
            shift @argv;
        } elsif ($argv[0] eq "--abort") { # TODO: make them a very specific
            confess ("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. -1]) . "\"") if (scalar @argv > 1);
            return ['ABORT'];
        } elsif ($argv[0] eq "--skip") {
            confess ("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. -1]) . "\"") if (scalar @argv > 1);
            return ['SKIP'];
        } elsif ($argv[0] eq "--continue") {
            confess ("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. -1]) . "\"") if (scalar @argv > 1);
            return ['CONTINUE'];
        } elsif (scalar @argv == 1) {
            return ['RUN', $argv[0], undef, $onto, \@through, $interactive];
        } elsif (scalar @argv == 2) {
            return ['RUN', $argv[0], $argv[1], $onto, \@through, $interactive];
        } else {
            confess ("Invalid arguments: \"" . join(" ", @argv) . "\"");
        }
    }
}

sub main_run($$$$) { my ($dest, $source_to, $onto, $through, $interactive) = @_;
    my $source_from = git_merge_base($dest, $source_to);
    # I'm not sure I understang original rebase logic here
    # trying to reproduce it
    if (defined $onto) {
        $dest = ${$onto};
    }
    my ($todo, $commits, $target_ref, $dest_hash) = init_rebase($dest, $source_from, $source_to, $through);
    if ($interactive) {
        my $ok;
        $todo = edit_todo($todo, $commits, \$ok);
        if (!$ok) {
            cleanup_save();
            print "Aborted\n";
            return;
        }
    }
    if (scalar @{$todo} > 0) {
        run_command("git checkout --quiet --detach $dest_hash");
        run_rebase($todo, $commits, $target_ref);
    } else {
        cleanup_save();
        print "Nothing to do\n";
    }
}

sub restore_rebase() {
    my $target_ref = read_file("$GIT_DIR/rebase2/target_ref");
    my $commits = git_load_commits();
    # TODO: add $unknown_commits  to $commits
    my $todo = read_todo("$GIT_DIR/rebase2/todo", $commits);
    my $current = 0;
    if (-e "$GIT_DIR/rebase2/current") {
        $current = get_single(read_todo("$GIT_DIR/rebase2/current", $commits));
    }
    return ($todo, $current, $commits, $target_ref);
}

sub init_rebase($$$$) { my ($dest, $source_from, $source_to, $through) = @_;
    my $target_ref = $source_to;
    #print Dumper($dest, $source_from, $source_to, $target_ref);
    #TODO: resolve all arguments
    my ($dest_hash, $source_from_hash, $source_to_hash) = git_resolve_hashes([$dest, $source_from, $source_to]);
    my @through_hashes;
    if (scalar @{$through} > 0) {
        @through_hashes = git_resolve_hashes($through);
    }
    init_save($target_ref);
    my $commits = git_fetch_commits($source_from, $source_to);
    my $todo = build_rebase_sequence($commits, $source_from_hash, $source_to_hash, \@through_hashes);
    # TODO: edit if interactive
    return ($todo, $commits, $target_ref, $dest_hash);
}

sub edit_todo($$$) { my ($old_todo, $commits, $ok) = @_;
    my ($tmpfh, $tmpname) = mkstemp("$GIT_DIR/rebase2/todo.XXXXXXXX");
    # TODO: write without reopen, to fh
    close($tmpfh) or confess ("Unable to close the tmpfile");
    save_todo($old_todo, $tmpname, $commits);
    my $editor = git_sequence_editor();
    my $new_todo =
        retry {
            run_command($editor . " $tmpname");
            # TODO: read unknown commits
            return read_todo($tmpname, $commits, { onSyntaxError => sub { die(@_, "\n"); } });
        } $ok;
    return $new_todo;
}

sub run_continue($$) { my ($current, $commits) = @_;
    run_command("git rev-parse --verify HEAD >/dev/null"
                . " && git update-index --ignore-submodules --refresh"
                . " && git diff-files --quiet --ignore-submodules");
    # TODO: restore proper rebase-like behavior
    if ($current->{type} eq "pick") {
        if (git_no_uncommitted_changes()) {
            # commited already
        } else {
            run_command("git commit -c $current->{ahash}");
        }
    } elsif ($current->{type} eq "edit") {
        if (git_no_uncommitted_changes()) {
            # commited already
        } else {
            confess("No unstaged changes should be after 'edit'");
        }
    } elsif ($current->{type} eq "fixup") {
        if (git_no_uncommitted_changes()) {
            # commited already
        } else {
            run_command("git commit --amend");
        }
    } elsif ($current->{type} eq "exec") {
        confess "Cannot continue 'exec $current->{command}'; resolve it manually, then skip or abort";
    } elsif ($current->{type} eq "comment") {
        comment($current->{comment});
    } else {
        confess "Type $current->{type} is unknown or not implemented";
    }
}

sub run_rebase($$$) { my ($todo, $commits, $target_ref) = @_;
    # TODO: handle errors
    while (defined (my $current = shift @{$todo})) {
        my $pause = 0;
        save_todo($todo, "$GIT_DIR/rebase2/todo", $commits);
        save_todo([$current], "$GIT_DIR/rebase2/current", $commits);
        run_step($current, $commits, \$pause);
        if ($pause) {
            return;
        }
        unlink("$GIT_DIR/rebase2/current");
    }
    # TODO: make proper reflog
    run_command("git checkout -B $target_ref");
    cleanup_save();
}

sub abort_rebase() {
    my $target_ref = read_file("$GIT_DIR/rebase2/target_ref");
    run_command("git reset --hard $target_ref");
    run_command("git checkout -f $target_ref");
    cleanup_save();
}

sub run_step($$$) { my ($rebase_step, $commits, $pause) = @_;
    if ($rebase_step->{type} eq "pick") {
        print "Apply: " . commits_get_subject($commits, $rebase_step->{ahash}) . "\n";
        pick($rebase_step->{ahash});
    } elsif ($rebase_step->{type} eq "edit") {
        print "Apply: " . commits_get_subject($commits, $rebase_step->{ahash}) . "\n";
        pick($rebase_step->{ahash});
        print "Amend the commit and run \"git rebase2 --continue\"\n";
        ${$pause} = 1;
    } elsif ($rebase_step->{type} eq "fixup") {
        print "Fixup: " . commits_get_subject($commits, $rebase_step->{ahash}). "\n";
        run_command("git cherry-pick --allow-empty --allow-empty-message --no-commit $rebase_step->{ahash} "
                    . "&& git commit --amend --no-edit");
    } elsif ($rebase_step->{type} eq "exec") {
        run_command($rebase_step->{command})
    } elsif ($rebase_step->{type} eq "comment") {
        print "Updating comment\n";
        comment($rebase_step->{comment});
    } elsif ($rebase_step->{type} eq "merge") {
        print "Merging\n";
        # to merge as non-first child:
        # 1. get the current position
        # 2. reset to the first child
        my $command = "git merge --no-edit";
        if ($rebase_step->{flags}->{ours}) {
            $command .= " --strategy=ours";
        }
        my @parents = @{$rebase_step->{parents}};
        my %parent_hashes = map { $_ => undef } git_resolve_hashes(\@parents);
        my $head_pos = find_only("HEAD", \@parents);
        if ($head_pos != 0) {
            # TODO: how to handle it in skip?
            # TODO: dont forget to make sure all parents are good cli args
            ($parents[$head_pos]) = git_resolve_hashes(["HEAD"]);
            run_command("git reset --hard $parents[0]");
        }
        shift @parents;
        foreach my $p (@parents) {
            $command .= " $p";
        }
        run_command($command);
        my ($head_hash) = git_resolve_hashes(["HEAD"]);
        if (exists $parent_hashes{$head_hash}) {
            # TODO: after newer merge is implemented, more data is available. Use it
            print "Merge of " . (join ",", @{$rebase_step->{parents}}) . " became noop or fastforward.\n";
            print "You would probably want to do now one of the following:\n";
            print " * force non-fastforward merge\n";
            print " * merge some other parent instead of the one from history\n";
            print " * skip the step at all (is it a non-interactive rebase?)\n";
            print "Then invoke git rebase2 --skip\n";
            die "Stopped";
        }
        comment($rebase_step->{comment});
    } else {
        confess "Type $rebase_step->{type} is unknown or not implemented";
    }
}

sub find_only ($\@) { my ($needle, $items) = @_;
    my $result = -1;
    my $pos = 0;
    foreach my $item (@{$items}) {
        if ($item eq $needle) {
            if ($result != -1) {
                confess("Duplicated $needle");
            } else {
                $result = $pos;
            }
        }
        ++$pos;
    }
    if ($result == -1) {
        confess("Not found: $needle");
    }
    return $result;
}

sub pick($) { my ($hash) = @_;
    # TODO: clear out all details
    run_command("git cherry-pick --allow-empty --allow-empty-message --ff $hash");
}

sub comment($) { my ($comment) = @_;
    write_file("$GIT_DIR/rebase2/commit_msg", $comment);
    run_command("git commit --amend -F \"$GIT_DIR/rebase2/commit_msg\"");
}

sub build_rebase_sequence($$$$) { my ($commits, $from, $to, $through) = @_;
    my @result;
    my $prev_hash = $from;
    foreach my $step_hash (@{find_sequence($commits->{by_hash}, $from, $to, $through)}) {
        if (scalar @{$commits->{by_hash}->{$step_hash}->{parents}} == 1) {
            push @result, { type => 'pick', ahash => $commits->{by_hash}->{$step_hash}->{ahash} };
        } else {
            push @result, make_merge_steps($step_hash, $prev_hash, $commits);
        }
        $prev_hash = $step_hash;
    }
    return \@result;
}

# TODO: tests, tests, tests
sub make_merge_steps($$\%) { my ($step_hash, $prev_hash, $commits) = @_;
    my $head_idx = find_only($prev_hash, @{$commits->{by_hash}->{$step_hash}->{parents}});
    my @parents_ahashes = map {
        if (exists $commits->{by_hash}->{$_}) {
            $commits->{by_hash}->{$_}->{ahash};
        } else {
            my $ahash = read_popen("git show -s --pretty=format:%h $_ --");
        }
    } @{$commits->{by_hash}->{$step_hash}->{parents}};
    my %merge_flags;
    if (system("git diff --quiet $step_hash $parents_ahashes[0]") == 0) {
        $merge_flags{ours} = 1;
    }
    $parents_ahashes[$head_idx] = "HEAD";
    my $comment = "";
    iterate_popen {
        $comment .= $_;
    } "git log --max-count=1 --pretty=format:%B $step_hash";
    return { type => "merge", comment => $comment, parents => \@parents_ahashes, flags => \%merge_flags };
}

sub git_resolve_hashes($) { my ($refs) = @_;
    foreach (@{$refs}) { verify_cmdarg($_); }
    my $refs_str = join " ", @{$refs};
    my @result = ();
    iterate_popen {
        s/^\s+|\s+$//g;
        push @result, $_;
    } "git rev-parse $refs_str";
    confess("Hash number does not match") unless (scalar @result == scalar @{$refs});
    return @result;
}

sub git_fetch_commits($$) { my ($from, $to) = @_;
    verify_cmdarg($from);
    verify_cmdarg($to);
    my $commits = {by_hash => {}, refs => {}};
    open(my $in, ">", "$GIT_DIR/rebase2/commits") or confess("Cannot write commits cache ($GIT_DIR/rebase2/commits): $!");
    iterate_popen {
        git_parse_commit_line($commits, $_);
        printf($in "%s", $_) or confess("Cannot write commits cache ($GIT_DIR/rebase2/commits): $!");
    } "git log --ancestry-path --pretty=format:%H:%h:%P:%s $from..$to";
    close($in) or confess("Cannot write commits cache ($GIT_DIR/rebase2/commits): $!");
    return $commits;
}

sub git_load_commits() {
    my $commits = {by_hash => {}, refs => {}};
    open(my $in, "<", "$GIT_DIR/rebase2/commits") or confess("Cannot read commits cache ($GIT_DIR/rebase2/commits): $!");
    while (<$in>) {
        git_parse_commit_line($commits, $_);
    }
    close($in);
    return $commits;
}

sub git_parse_commit_line($$) { my ($commits, $line) = @_;
    if ($line =~ /^([0-9a-f]+):([0-9a-f]+):([0-9a-f ]*):(.*)\x{a}?$/) {
        my $hash = $1;
        my $ahash = $2;
        my @parents = split(/ /, $3);
        my $subject = $4;
        verify_hash($hash);
        foreach my $p (@parents) { verify_hash($p); }
        if (!exists $commits->{by_hash}->{$hash}) {
            my $obj = {parents => \@parents, subject => $subject, hash => $hash, ahash => $ahash};
            $commits->{by_hash}->{$hash} = $obj;
        }
        if (exists $commits->{refs}->{$ahash}) {
            if ($commits->{refs}->{$ahash} ne $hash) {
                confess("duplicated ref with different hash: $ahash => $hash, $commits->{refs}->{$ahash}");
            }
        } else {
            $commits->{refs}->{$ahash} = $hash;
        }
    } else {
        confess("Could not parse line: $line");
    }
}

sub git_merge_base($$) { my ($b1, $b2) = @_;
    verify_cmdarg($b1);
    verify_cmdarg($b2);
    my $result = "";
    my $hit = 0;
    iterate_popen {
        s/^\s+|\s+$//g;
        if (!$hit) {
            $result = $_;
            $hit = 1;
        } else {
            confess "Multiple merge-bases for $b1 and $b2";
        }
    } "git merge-base -a $b1 $b2";
    if (!$hit) {
        confess "Merge-base not found for $b1 and $b2"
    }
    return $result;
}

sub git_sequence_editor() {
    if (exists $ENV{GIT_SEQUENCE_EDITOR}) {
        return $ENV{GIT_SEQUENCE_EDITOR};
    }

    foreach my $cmd ("git config sequence.editor || true", "git var GIT_EDITOR || true") {
        my $git_editor = read_popen($cmd);
        if ($git_editor ne "") {
            return $git_editor;
        }
    }

    confess ("Editor not found");
}

sub run_command($) { my ($command) = @_;
    my $ret = system($command);
    confess("Command failed: $ret") unless ($ret == 0);
}

sub read_popen($) { my ($command) = @_;
    my $res = "";
    iterate_popen { $res .= $_; } $command;
    $res =~ s/^\s+|\s+$//g;
    return $res;
}

sub verify_hash($) { my ($str) = @_;
    # allow abbreviated
    if ($str !~ /^[0-9a-f]{40}$/) {
        confess "Invalid hash: $str";
    }
}

sub verify_cmdarg($) { my ($str) = @_;
    if ($str =~ /["'\\\(\)#]|[\x00- ]/) {
        confess "Invalid cmdarg: $str";
    }
}

sub init_save($) { my ($target_ref) = @_;
    if (-e "$GIT_DIR/rebase2") {
        confess "already in progress?";
    }
    mkdir("$GIT_DIR/rebase2") or confess "Mkdir $GIT_DIR/rebase2 failed: $!";
    write_file("$GIT_DIR/rebase2/target_ref", $target_ref);
}

sub cleanup_save() {
    # will throw itself
    rmtree("$GIT_DIR/rebase2");
}

sub commits_get_subject($$) { my ($commits, $ref) = @_;
    # TODO: not existing keys be assertions as soon as reading of unknown commits is imlemented
    if (!exists $commits->{refs}->{$ref}) {
        return "???";
    }
    my $hash = $commits->{refs}->{$ref};
    if (!exists $commits->{by_hash}->{$hash}) {
        return "???";
    }
    return $commits->{by_hash}->{$hash}->{subject};
}

sub save_todo($$$) { my ($todo, $file, $commits) = @_;
    with_output_file($file, sub { my ($out) = @_;
        foreach my $step (@{$todo}) {
            if ($step->{type} eq "pick") {
                print $out "pick $step->{ahash} " . commits_get_subject($commits, $step->{ahash}) . "\n";
            } elsif ($step->{type} eq "edit") {
                print $out "edit $step->{ahash} " . commits_get_subject($commits, $step->{ahash}) . "\n";
            } elsif ($step->{type} eq "fixup") {
                print $out "fixup $step->{ahash} " . commits_get_subject($commits, $step->{ahash}) . "\n";
            } elsif ($step->{type} eq "exec") {
                if ($step->{command} =~ /\n/) {
                    confess "multiline command cannot be saved";
                }
                print $out "exec $step->{command}\n";
            } elsif ($step->{type} eq "comment") {
                print $out "comment\n";
                write_todo_comment($out, $step->{comment});
            } elsif ($step->{type} eq "merge") {
                my $flags_str = "";
                if ($step->{flags}->{ours}) {
                    $flags_str .= " --ours"
                }
                my $parents_str = join " ", @{$step->{parents}};
                print $out "merge$flags_str $parents_str\n";
                write_todo_comment($out, $step->{comment});
            } else {
                confess "Type $step->{type} is unknown or not implemented";
            }
        }
    });
}

sub write_todo_comment($$) { my ($out, $comment) = @_;
    while ($comment =~ /\n\.\n/) {
        $comment =~ s/\n\.\n/\n/;
    }
    print $out "$comment";
    if (substr($comment, -1) ne "\n") {
        print $out "\n";
    }
    print $out ".\n";
}

sub default_error($) { my ($msg) = @_;
    confess($msg);
}

# TODO for caching refs
# * add to commits aliases (refs, whatever), which map entered aliases to commits
# * save and restore them to something like rebase2/commit_refs
# * refer to the refs dictionary in read_todo()
# * fill missing refs and missing commits in the following function
# * consider splitting the resolving part; I believe it should be possible to handle all state in todo+commits
#   * describe the data structure
# * use git_resolve_hashes() for resolving refs, git show ... for getting info

sub read_todo($$;\$) { my ($filename, $commits, $errorHandler) = @_;
    my $onSyntaxError = (defined $errorHandler && exists $errorHandler->{onSyntaxError}) ? $errorHandler->{onSyntaxError} : \&default_error ;
    my $todo = [];
    open(my $in, "<", $filename) or confess "Cannot open file $filename: $!";
    my $mode = "COMMAND";
    my $comment = "";
    my $merge_flags = undef;
    my $merge_parents = undef;
    while (<$in>) {
        if ($mode eq "COMMAND") {
            if (/^#.*$/) {
            } elsif (/^(f|fixup) ([0-9a-f]+)( (.*))?$/) {
                push @{$todo}, {type => "fixup", ahash => $2};
            } elsif (/^(p|pick) ([0-9a-f]+)( (.*))?$/) {
                push @{$todo}, {type => "pick", ahash => $2};
            } elsif (/^(e|edit) ([0-9a-f]+)( (.*))?$/) {
                push @{$todo}, {type => "edit", ahash => $2};
            } elsif (/^(x|exec) (.+)$/) {
                push @{$todo}, {type => "exec", command => $2};
            } elsif (/^comment\b/) {
                $mode = "COMMENT";
                $comment = "";
            } elsif (/^merge( --ours)? (.+[^\n\r ])$/) {
                $mode = "MERGE_COMMENT";
                $comment = "";
                $merge_parents = [split / +/, $2];
                # TODO: verify as refs
                $merge_flags = {};
                if ($1) {
                    $merge_flags->{ours} = 1;
                }
            } elsif (/^[[:space:]]*$/) {
            } else {
                s/\n//;
                $onSyntaxError->("Unrecognised todo line for mode $mode: \"$_\"");
            }
        } elsif ($mode eq "COMMENT") {
            if (/^#.*$/) {
            } elsif (/^\.$/) {
                $mode = "COMMAND";
                push @{$todo}, {type => "comment", comment => $comment};
            } else {
                $comment = $comment . $_;
            }
        } elsif ($mode eq "MERGE_COMMENT") {
            if (/^#.*$/) {
            } elsif (/^\.$/) {
                $mode = "COMMAND";
                push @{$todo}, {type => "merge", comment => $comment, parents => $merge_parents, flags => $merge_flags};
            } else {
                $comment = $comment . $_;
            }
        } else {
            $onSyntaxError->("Unexpected mode: $mode");
        }
    }
    close($in);
    if ($mode ne "COMMAND") {
        $onSyntaxError->("Unterminated comment");
    }
    # TODO: resolve the $unknown_commits
    return $todo;
}

sub with_output_file($$) { my ($filename, $proc) = @_;
    open(my $out, ">", $filename + ".new") or confess "Cannot open file $filename.new: $!";
    $proc->($out);
    close($out) or confess "Cannot close output file $filename.new: $!";
    rename($filename + ".new", $filename) or "Cannot replace output file $filename: $!";
}

sub write_file($$) { my ($filename, $str) = @_;
    with_output_file($filename, sub { my ($out) = @_;
        print $out $str;
    });
}

sub read_file($) { my ($filename) = @_;
    open(my $out, "<", $filename) or confess "Cannot open file $filename: $!";
    my $data = "";
    if (read($out, $data, 1024) <= 0) {
        confess "Read failed: $!";
    }
    close($out) or confess "Cannot close file $filename: $!";
    return $data;
}

sub get_single(\@) { my ($array) = @_;
    if (scalar @{$array} != 1) {
        confess ("Should be an array with single element: " . Dumper($array));
    }
    return $array->[0];
}


# $commits : { $hash => { parents => [ $hash ] } }
sub find_sequence($$$$) { my ($commits, $from, $to, $through_list) = @_;
    # TODO:
    # + through
    # + explicitly forbid inner merges
    # * inner merges
    #  * interface
    #  * extraction

    # initialize data
    my %through_hash = ();
    @through_hash{@{$through_list}} = ();
    my %commitsX = ();
    foreach my $h (keys %{$commits}) {
        $commitsX{$h} = { children_count => 0, children => [] };
    }
    $commitsX{$from} = { children_count => 0, children => [] };
    $commitsX{$to} = { children_count => 0, children => [], cost => [0, {}] };
    # fill children_count for each commit
    foreach my $h (keys %{$commits}) {
        foreach my $p (@{$commits->{$h}->{parents}}) {
            if (exists $commitsX{$p}) {
                $commitsX{$p}->{children_count}++;
            }
        }
    }
    # main step - mark each commit with cost and best child
    my %edge = ($to => 1);
    while (scalar %edge) {
        my %next_edge = ();
        foreach my $v (keys %edge) {
            my $vertex_cost = $commitsX{$v}->{cost};
            foreach my $p (@{$commits->{$v}->{parents}}) {
                push(@{$commitsX{$p}->{children}}, $v);
                if (scalar @{$commitsX{$p}->{children}} == $commitsX{$p}->{children_count}) {
                    # all children are filled, find the best one
                    my ($min_cost, $min_child) = find_minimal_cost(map { [$commitsX{$_}->{cost}, $_] } @{$commitsX{$p}->{children}});
                    $commitsX{$p}->{cost} = [$min_cost->[0] + 1, $min_cost->[1]];
                    if (exists $through_hash{$p}) {
                        my %new_set = %{$commitsX{$p}->{cost}->[1]};
                        $new_set{$p} = ();
                        $commitsX{$p}->{cost}->[1] = \%new_set;
                    }
                    $commitsX{$p}->{sequence_child} = $min_child;
                    $next_edge{$p} = 1;
                }
            }
        }
        %edge = %next_edge;
    }
    # collect the path by child marks
    my @res = ();
    my $next = $from;
    while ($next ne $to) {
        $next = $commitsX{$next}->{sequence_child};
        if ($commitsX{$next}->{children_count} > 1) {
            confess("inner merges not supported yet (found in commit $next)");
        }
        push @res, $next;
    }
    return \@res;
}

sub find_minimal_cost(@) {
    my @result = (undef, undef);
    foreach my $item (@_) {
        if (!defined $result[0] || do {
                my ($result_cost, $result_marks) = @{$result[0]};
                my ($item_cost, $item_marks) = @{$item->[0]};
                if (is_subset($result_marks, $item_marks)) {
                    if (is_subset($item_marks, $result_marks)) {
                        # they are equal
                        $result_cost > $item_cost;
                    } else {
                        1;
                    }
                } else {
                    if (is_subset($item_marks, $result_marks)) {
                        0;
                    } else {
                        my $result_marks_line = join ",", keys %$result_marks;
                        my $item_marks_line = join ",", keys %$item_marks;
                        confess("Non-subsequent throughs not supported (met [$result_marks_line] vs [$item_marks_line])");
                    }
                }
             }) {
            @result = @{$item};
        }
    }
    return @result;
}

sub is_subset(\%\%) { my ($sub, $super) = @_;
    foreach my $k (keys %$sub) {
        if (!exists $super->{$k}) {
            return 0;
        }
    }
    return 1;
}

# TODO: options parser
# * interactive
# * continue, abort

if ($0 !~ /test\.pl/) {
    main(\@ARGV);
}
