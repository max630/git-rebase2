#!/usr/bin/env perl

use strict;
use feature 'switch';

use Data::Dumper;
use Carp;

sub main ($$) { my ($dest, $source_to) = @_;
    my $target_ref = $source_to;
    my $source_from = git_merge_base($dest, $source_to);
    #print Dumper($dest, $source_from, $source_to, $target_ref);
    #TODO: resolve all arguments
    my ($dest_hash, $source_to_hash) = git_resolve_hashes([$dest, $source_to]);
    my $commits = git_fetch_commits($source_from, $source_to);
    my $rebase_sequence = build_rebase_sequence($commits, $source_to_hash);
    # TODO: edit if interactive
    run_command("git checkout --detach $dest_hash");
    run_rebase($rebase_sequence, $commits);
    run_command("git branch -f $target_ref");
}

sub run_rebase($) { my ($rebase_sequence, $commits) = @_;
    # TODO: handle errors
    foreach (@{$rebase_sequence}) { run_step($_, $commits); }
}

sub run_step($) { my ($rebase_step, $commits) = @_;
    given($rebase_step->{type}) {
        when ("pick") {
            my $subject = (split /\n/, $commits->{$rebase_step->{hash}}->{comment})[0];
            print "Apply: $subject\n";
            pick($rebase_step->{hash});
        }
        default {
            confess "Type $rebase_step->{type} is unknown or not implemented";
        }
    }
}

sub pick($) { my ($hash) = @_;
    # TODO: clear out all details
    run_command("git cherry-pick --allow-empty --allow-empty-message --ff $hash");
}

sub build_rebase_sequence($$) { my ($commits, $top_hash) = @_;
    confess("Invalid top hash: $top_hash") unless (exists $commits->{$top_hash});
    my @result = ();
    my $hash = $top_hash;
    do {
        push @result, {type => 'pick', hash => $hash};
        my $parents = $commits->{$hash}->{parents};
        confess("Multiple parents for $hash") unless ($#{$parents} == 0);
        $hash = $parents->[0];
    } while (exists $commits->{$hash}); # TODO: use bottom_hash instead
    @result = reverse @result;
    return \@result;
}

sub git_resolve_hashes($) { my ($refs) = @_;
    foreach (@{$refs}) { verify_cmdarg($_); }
    my $refs_str = join " ", @{$refs};
    my @result = ();
    iterate_popen("git rev-parse $refs_str", sub {
        s/^\s+|\s+$//g;
        push @result, $_;
    });
    confess("Hash number does not match") unless ($#result == $#{$refs});
    return @result;
}

sub git_fetch_commits($$) { my ($from, $to) = @_;
    verify_cmdarg($from);
    verify_cmdarg($to);
    my $commits = {};
    my $buffer = "";
    iterate_popen("git log --ancestry-path --pretty=format:%H%x00%P%x00%B%x00 $from..$to",
                  sub {
        $buffer = $buffer . $_;
        if ($buffer =~ /^([^\x00]*)\x00([^\x00]*)\x00([^\x00]*)\x00\x{a}?(.*)$/s) {
            my $hash = $1;
            my @parents = split(/ /, $2);
            my $comment = $3;
            $buffer = $4;
            verify_hash($hash);
            foreach my $p (@parents) { verify_hash($p); }
            if (exists $commits->{$hash}) {
                confess "Duplicated commit: $hash";
            }
            $commits->{$hash} = {parents => \@parents, comment => $comment};
        }
    });
    if ($buffer ne "") {
        confess "Leftover buffer: $buffer";
    }
    return $commits;
}

sub git_merge_base($$) { my ($b1, $b2) = @_;
    verify_cmdarg($b1);
    verify_cmdarg($b2);
    my $result = "";
    my $hit = 0;
    iterate_popen("git merge-base -a $b1 $b2", sub {
        s/^\s+|\s+$//g;
        if (!$hit) {
            $result = $_;
            $hit = 1;
        } else {
            confess "Multiple merge-bases for $b1 and $b2";
        }
    });
    if (!$hit) {
        confess "Merge-base not found for $b1 and $b2"
    }
    return $result;
}

sub run_command($) { my ($command) = @_;
    my $ret = system($command);
    confess("Command failed: $ret") unless ($ret == 0);
}

sub iterate_popen($$) { my ($command, $code) = @_;
    open(my $in, "-|", $command) or confess "Cannot start a program: $!";
    while (<$in>) {
        $code->($_);
    }
    close ($in) or confess "Program failed";
}

sub verify_hash($) { my ($str) = @_;
    if ($str !~ /^[0-9a-f]{40}$/) {
        confess "Invalid hash: $str";
    }
}

sub verify_cmdarg($) { my ($str) = @_;
    if ($str =~ /["'\\\(\)#]|[\x00- ]/) {
        confess "Invalid cmdarg: $str";
    }
}

# TODO: options parser
# * interactive
# * continue, abort
main($ARGV[0], $ARGV[1]);
