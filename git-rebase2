#!/usr/bin/env perl

# vim: foldmethod=marker

use strict;

use Data::Dumper;
use Carp;
use File::Path qw(rmtree);
use File::Temp qw(:mktemp);

my $GIT_DIR = read_popen("git rev-parse --git-dir");
# full list of invalid sylbols is unclear.
# definitely no \ or " (to be used in command-line), what else?
# be safe here
if ($GIT_DIR !~ /^[-a-z0-9_\.,\/ ]+$/i) {
    confess("Some unsupported symbols in: $GIT_DIR");
}

# {{{ utils

sub retry (&$) { my ($code, $ok) = @_;
    my $warray = wantarray;
    while (1) {
        my $result;
        my @result;
        if ($warray) {
            @result = eval { $code->(); }
        } else {
            $result = eval { $code->(); }
        }
        if ($@ ne "") {
            print "Error: $@";
            print "Retry (y/N)?";
            my $answer = <STDIN>;
            if ($answer !~ /^y.*/i) {
                ${$ok} = 0;
                return;
            }
        } else {
            ${$ok} = 1;
            if ($warray) {
                return @result;
            } else {
                return $result;
            }
        }
    }
}

package guard {
    sub new ($&) { my ($class, $sub) = @_;
        return (bless { sub => $sub }, $class);
    }

    sub DESTROY($) { my ($self) = @_;
        $self->{sub}->();
    }
}

# }}}

# {{{ io utils
sub iterate_popen(&$) { my ($code, $command) = @_;
    open(my $in, "-|", $command) or confess "Cannot start a program: $!";
    while (<$in>) {
        $code->($_);
    }
    close ($in) or confess "Program failed";
}

sub iterate_file(&$) { my ($code, $filename) = @_;
    open(my $in, "<", $filename) or confess "Cannot open \"$filename\": $!";
    while (<$in>) {
        $code->($_);
    }
    close ($in);
}
# }}}

# {{{ git utils

sub git_no_uncommitted_changes()
{
    return (system("git diff-index --quiet --ignore-submodules HEAD") == 0);
}

sub git_verify_clean()
{
    confess "Not clean working directory" unless git_no_uncommitted_changes();
    confess "git-am or rebase in progress" if -e "$GIT_DIR/rebase-apply";
    confess "rebase in progress" if -e "$GIT_DIR/rebase-merge";
}

sub git_get_checkedout_branch()
{
    my $head_path = read_popen("git symbolic-ref -q HEAD");
    if ($head_path =~ /refs\/heads\/(.*)/) {
        return $1;
    } else {
        confess("Unsupported ref checked-out: $head_path");
    }
}

# }}}

# {{{ DOC: Types
#
# $commits = {
#   head => { type => "known_hash", hash => String } | { type => "synced" }
#   refs => { $ref => $hash },
#   marks => { $mark => $hash }.
#   by_hash => { $hash => Entry },
# }
# ref is ahash or symbolic ref
#
# Entry is {
#   ahash => String,
#   hash => String[40],
#   subject => String,
#   parents => [String[40]],
# }
#
# $todo = [ Step ]
#
# Step is {
#   type => String,
#   ...
# } is {
#   type => one of("pick", "fixup", "edit"),
#   ahash => String
# } or {
#   type => "exec",
#   command => String
# } or {
#   type => "comment",
#   comment => String
# } or {
#   type => "merge",
#   (optional) ahash => String,
#   parents => [String],
#   flags => {
#       (optional) ours => Int
#   }
# } or {
#   type => "mark"
#   name => String
# } or {
#   type => "reset"
#   ahash => String
# }
#
# }}}

sub main($) { my ($argv) = @_;
    my $parsed = parse_cli($argv);
    if (0) {
    } elsif ($parsed->[0] eq "ABORT") {
        abort_rebase();
    } elsif ($parsed->[0] eq "CONTINUE") {
        my ($todo, $current, $commits, $target_ref) = restore_rebase();
        if ($current) {
            run_continue($current, $commits);
            unlink("$GIT_DIR/rebase2/current");
        }
        $commits->{head} = { type => "synced" };
        run_rebase($todo, $commits, $target_ref);
    } elsif ($parsed->[0] eq "SKIP") {
        my ($todo, $current, $commits, $target_ref) = restore_rebase();
        if ($current) {
            run_command("git reset --hard HEAD");
            unlink("$GIT_DIR/rebase2/current");
        }
        $commits->{head} = { type => "synced" };
        run_rebase($todo, $commits, $target_ref);
    } elsif ($parsed->[0] eq "RUN") {
        my ($tag, $dest, $source_from_arg, $through, $source_to_arg, $target_arg, $interactive) = @{$parsed};
        git_verify_clean();
        my $initial_branch = git_get_checkedout_branch();
        my $target_ref = do { if ($target_arg ne "") { $target_arg; } else { $initial_branch }};
        my $source_to = do { if ($source_to_arg ne "") { $source_to_arg } else { $target_ref }};
        my $source_from = do { if ($source_from_arg ne "") { $source_from_arg } else { git_merge_base($source_to, $dest); }};
        main_run($dest, $source_from, $through, $source_to, $target_ref, $initial_branch, $interactive);
    } else {
        confess("Unexpected: " . Data::Dumper($parsed));
    }
}

sub parse_cli($) { my @argv = @{$_[0]};
    my $interactive = 0;
    while (1) {
        if (0) {
        } elsif ($argv[0] eq "-i" || $argv[0] eq "--interactive") {
            $interactive = 1;
            shift @argv;
        } elsif ($argv[0] eq "--abort") { # TODO: make them a very specific
            confess ("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. -1]) . "\"") if (scalar @argv > 1);
            return ['ABORT'];
        } elsif ($argv[0] eq "--skip") {
            confess ("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. -1]) . "\"") if (scalar @argv > 1);
            return ['SKIP'];
        } elsif ($argv[0] eq "--continue") {
            confess ("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. -1]) . "\"") if (scalar @argv > 1);
            return ['CONTINUE'];
        } elsif (scalar @argv == 1) {
            return ['RUN', $argv[0], undef, [], undef, undef, $interactive];
        } elsif (scalar @argv == 3 || scalar @argv == 2 && $argv[1] =~ /\.\./) {
            my ($source_from, $through, $source_to) = do {
                my $re_ref0 = qr/(?:[^\.]|(?<!\.)\.)*/;
                my $re_ref1 = qr/(?:[^\.]|(?<!\.)\.)+/;
                my $re_sep = qr/(?<!\.)\.\./;
                if ($argv[1] eq "") {
                    (undef, undef, undef);
                } elsif ($argv[1] =~ /^($re_ref0)$re_sep((?:$re_ref1$re_sep)*)($re_ref0)$/x) {
                    my ($source_from, $source_to) = ($1, $3);
                    my @through_arr = $2 =~ m/($re_ref1)$re_sep/g;
                    ($source_from, \@through_arr, $source_to);
                } else {
                    confess("Invalid source spec: $argv[1]");
                }
            };
            return ['RUN', $argv[0], $source_from, $through, $source_to, $argv[2], $interactive];
        } elsif (scalar @argv == 2) {
            return ['RUN', $argv[0], undef, [], undef, $argv[1], $interactive];
        } else {
            confess ("Invalid arguments: \"" . join(" ", @argv) . "\"");
        }
    }
}

sub main_run($$$$$$$) { my ($dest, $source_from, $through, $source_to, $target_ref, $initial_branch, $interactive) = @_;
    my ($todo, $commits, $dest_hash) = init_rebase($dest, $source_from, $through, $source_to, $target_ref, $initial_branch);
    if ($interactive) {
        my $ok;
        $todo = edit_todo($todo, $commits, \$ok);
        if (!$ok) {
            cleanup_save();
            print "Aborted\n";
            return;
        }
    }
    if (scalar @{$todo} > 0) {
        $commits->{head} = { type => "known_hash", hash => $dest_hash };
        save_todo($todo, "$GIT_DIR/rebase2/todo.backup", $commits);
        run_command("git checkout --quiet --detach $dest_hash");
        run_rebase($todo, $commits, $target_ref);
    } else {
        cleanup_save();
        print "Nothing to do\n";
    }
}

sub restore_rebase() {
    my $target_ref = read_file("$GIT_DIR/rebase2/target_ref");
    my $commits = git_load_commits();
    # TODO: add $unknown_commits  to $commits
    my $todo = read_todo("$GIT_DIR/rebase2/todo", $commits);
    my $current = 0;
    if (-e "$GIT_DIR/rebase2/current") {
        $current = get_single(read_todo("$GIT_DIR/rebase2/current", $commits));
    }
    return ($todo, $current, $commits, $target_ref);
}

sub init_rebase($$$$$) { my ($dest, $source_from, $through, $source_to, $target_ref, $initial_branch) = @_;
    #print Dumper($dest, $source_from, $source_to, $target_ref);
    #TODO: resolve all arguments
    my ($dest_hash, $source_from_hash, $source_to_hash) = git_resolve_hashes([$dest, $source_from, $source_to]);
    my @through_hashes;
    if (scalar @{$through} > 0) {
        @through_hashes = git_resolve_hashes($through);
    }
    init_save($target_ref, $initial_branch);
    my $commits = git_fetch_commits($source_from, $source_to);
    my $todo = build_rebase_sequence($commits, $source_from_hash, $source_to_hash, \@through_hashes);
    # TODO: edit if interactive
    return ($todo, $commits, $dest_hash);
}

sub edit_todo($$$) { my ($old_todo, $commits, $ok) = @_;
    my ($tmpfh, $tmpname) = mkstemp("$GIT_DIR/rebase2/todo.XXXXXXXX");
    # TODO: write without reopen, to fh
    close($tmpfh) or confess ("Unable to close the tmpfile");
    save_todo($old_todo, $tmpname, $commits);
    my $editor = git_sequence_editor();
    my $new_todo =
        retry {
            run_command($editor . " $tmpname");
            # TODO: read unknown commits
            return read_todo($tmpname, $commits, { onSyntaxError => sub { die(@_, "\n"); } });
        } $ok;
    return $new_todo;
}

sub run_continue($$) { my ($current, $commits) = @_;
    run_command("git rev-parse --verify HEAD >/dev/null"
                . " && git update-index --ignore-submodules --refresh"
                . " && git diff-files --quiet --ignore-submodules");
    # TODO: restore proper rebase-like behavior
    if ($current->{type} eq "pick" || $current->{type} eq "merge") {
        if (git_no_uncommitted_changes()) {
            # commited already
        } else {
            run_command("git commit -c $current->{ahash}");
        }
    } elsif ($current->{type} eq "edit") {
        if (git_no_uncommitted_changes()) {
            # commited already
        } else {
            confess("No unstaged changes should be after 'edit'");
        }
    } elsif ($current->{type} eq "fixup") {
        if (git_no_uncommitted_changes()) {
            # commited already
        } else {
            run_command("git commit --amend");
        }
    } elsif ($current->{type} eq "exec") {
        confess "Cannot continue 'exec $current->{command}'; resolve it manually, then skip or abort";
    } elsif ($current->{type} eq "comment") {
        comment($current->{comment});
    } else {
        confess "Type $current->{type} is unknown or not implemented";
    }
}

sub run_rebase($$$) { my ($todo, $commits, $target_ref) = @_;
    # TODO: handle errors
    {
        my $g = guard->new(sub {
            eval { sync_head($commits); };
            if ($@ ne "") {
                print "Fatal error while syncing: $@\nContinue not possible\n";
                unlink("$GIT_DIR/rebase2/todo");
            }
        });
        while (defined (my $current = shift @{$todo})) {
            my $pause = 0;
            save_todo($todo, "$GIT_DIR/rebase2/todo", $commits);
            save_todo([$current], "$GIT_DIR/rebase2/current", $commits);
            run_step($current, $commits, \$pause);
            if ($pause) {
                return;
            }
            unlink("$GIT_DIR/rebase2/current");
        }
    }
    # TODO: make proper reflog
    run_command("git checkout -B $target_ref");
    cleanup_save();
}

sub abort_rebase() {
    my $initial_branch = read_file("$GIT_DIR/rebase2/initial_branch");
    run_command("git reset --hard $initial_branch");
    run_command("git checkout -f $initial_branch");
    cleanup_save();
}

sub resolve_ahash($$) { my ($ahash, $commits) = @_;
    if ($ahash =~ /^\@([0-9a-zA-Z_]+)$/) {
        confess("Mark $1 not found") unless exists $commits->{marks}->{$1};
        return $commits->{marks}->{$1};
    } elsif (exists $commits->{refs}->{$ahash}) {
        return $commits->{refs}->{$ahash};
    } else {
        return $ahash;
    }
}

sub run_step($$$) { my ($rebase_step, $commits, $pause) = @_;
    if ($rebase_step->{type} eq "pick") {
        pick(resolve_ahash($rebase_step->{ahash}, $commits), $commits);
    } elsif ($rebase_step->{type} eq "edit") {
        print "Apply: " . commits_get_subject($commits, $rebase_step->{ahash}) . "\n";
        pick(resolve_ahash($rebase_step->{ahash}, $commits), $commits);
        sync_head($commits);
        print "Amend the commit and run \"git rebase2 --continue\"\n";
        ${$pause} = 1;
    } elsif ($rebase_step->{type} eq "fixup") {
        print "Fixup: " . commits_get_subject($commits, $rebase_step->{ahash}). "\n";
        sync_head($commits);
        run_command("git cherry-pick --allow-empty --allow-empty-message --no-commit " . resolve_ahash($rebase_step->{ahash}, $commits)
                    . " && git commit --amend --no-edit");
    } elsif ($rebase_step->{type} eq "reset") {
        my $hash_or_ref = resolve_ahash($rebase_step->{ahash}, $commits);
        if (exists $commits->{by_hash}->{$hash_or_ref}) {
            $commits->{head} = { type => "known_hash", hash => $hash_or_ref };
        } else {
            run_command("git reset --hard $hash_or_ref");
            $commits->{head} = { type => "synced" };
        }
    } elsif ($rebase_step->{type} eq "exec") {
        sync_head($commits);
        run_command($rebase_step->{command})
    } elsif ($rebase_step->{type} eq "comment") {
        print "Updating comment\n";
        sync_head($commits);
        comment($rebase_step->{comment});
    } elsif ($rebase_step->{type} eq "mark") {
        my $head_hash = do {
            if ($commits->{head}->{type} eq "known_hash") {
                $commits->{head}->{hash};
            } elsif ($commits->{head}->{type} eq "synced") {
                get_single([git_resolve_hashes(["HEAD"])]);
            } else {
                confess("Unknown head type: $commits->{head}->{type}");
            }
        };
        $commits->{marks}->{$rebase_step->{name}} = $head_hash;
        # TODO: save and restore the head
        my $out;
        open($out, ">>", "$GIT_DIR/rebase2/marks")
            and print $out "$rebase_step->{name} $head_hash\n"
            and close($out)
            or confess("Write to \"$GIT_DIR/rebase2/marks\" failed: $!");
    } elsif ($rebase_step->{type} eq "merge") {
        merge($rebase_step, $commits);
    } else {
        confess "Type $rebase_step->{type} is unknown or not implemented";
    }
}

sub merge($$) { my ($rebase_step, $commits) = @_;
    if ($commits->{head}->{type} eq "known_hash" &&
        exists $rebase_step->{ahash} &&
        exists $commits->{refs}->{$rebase_step->{ahash}} &&
        exists $commits->{by_hash}->{$commits->{refs}->{$rebase_step->{ahash}}})
    {
        my $merge_parents_refs = $rebase_step->{parents};
        my $step_hash = $commits->{refs}->{$rebase_step->{ahash}};
        my $commit_parents = $commits->{by_hash}->{$step_hash}->{parents};
        if (scalar @{$merge_parents_refs} == scalar @{$commit_parents}) {
            my $match = 1;
            for (my $i = 0; $match && $i < @{$merge_parents_refs}; ++$i) {
                if ($merge_parents_refs->[$i] eq "HEAD") {
                    $match = $commits->{head}->{hash} eq $commit_parents->[$i];
                } else {
                    my $resolved = resolve_ahash($merge_parents_refs->[$i], $commits);
                    if ($resolved eq $commit_parents->[$i]) {
                        $match = 1;
                    } elsif ($resolved =~ /^[0-9a-zA-Z_]+$/ && (substr $commit_parents->[$i], 0, length $resolved) eq $resolved) {
                        # cheating here; $commits should have been known about it if I implement them properly
                        $match = 1;
                    } else {
                        $match = 0;
                    }
                }
            }
            if ($match) {
                print "Fast-forwarding merge: $rebase_step->{ahash} $commits->{by_hash}->{$step_hash}->{subject}\n";
                $commits->{head}->{hash} = $step_hash;
            } else {
                merge_noff($rebase_step, $commits);
            }
        } else {
            merge_noff($rebase_step, $commits);
        }
    } else {
        merge_noff($rebase_step, $commits);
    }
}

sub merge_noff($$) { my ($rebase_step, $commits) = @_;
    sync_head($commits);
    print "Merging\n";
    # to merge as non-first child:
    # 1. get the current position
    # 2. reset to the first child
    my $command = "git merge";
    if (exists $rebase_step->{ahash}) {
        $command .= " --no-commit";
    } else {
        $command .= " --no-edit";
    }
    if ($rebase_step->{flags}->{ours}) {
        $command .= " --strategy=ours";
    }
    my @parents = map { resolve_ahash($_, $commits) } @{$rebase_step->{parents}};
    my %parent_hashes = map { $_ => undef } git_resolve_hashes(\@parents);
    my $head_pos = find_only("HEAD", \@parents);
    if ($head_pos != 0) {
        # TODO: how to handle it in skip?
        # TODO: dont forget to make sure all parents are good cli args
        ($parents[$head_pos]) = git_resolve_hashes(["HEAD"]);
        run_command("git reset --hard $parents[0]");
    }
    shift @parents;
    foreach my $p (@parents) {
        $command .= " $p";
    }
    run_command($command);
    if (exists $rebase_step->{ahash}) {
        run_command("git commit -C " . resolve_ahash($rebase_step->{ahash}, $commits) . " --reset-author");
    }
}

sub find_only ($\@) { my ($needle, $items) = @_;
    my $result = -1;
    my $pos = 0;
    foreach my $item (@{$items}) {
        if ($item eq $needle) {
            if ($result != -1) {
                confess("Duplicated $needle");
            } else {
                $result = $pos;
            }
        }
        ++$pos;
    }
    if ($result == -1) {
        confess("Not found: $needle");
    }
    return $result;
}

sub sync_head($) { my ($commits) = @_;
    if ($commits->{head}->{type} eq "known_hash") {
        run_command("git reset --hard $commits->{head}->{hash}");
        $commits->{head} = { type => "synced" };
    } elsif ($commits->{head}->{type} eq "synced") {
        # nothing to do
    } else {
        confess("Unknown head type: $commits->{head}->{type}");
    }
}

sub pick($$) { my ($hash, $commits) = @_;
    if ($commits->{head}->{type} eq "known_hash") {
        if (exists $commits->{by_hash}->{$hash} &&
            scalar @{$commits->{by_hash}->{$hash}->{parents}} == 1 &&
            scalar $commits->{by_hash}->{$hash}->{parents}->[0] eq $commits->{head}->{hash}) {
            print "Fast-forwarding: $commits->{by_hash}->{$hash}->{ahash} $commits->{by_hash}->{$hash}->{subject}\n";
            $commits->{head}->{hash} = $hash;
        } else {
            print "Apply: $commits->{by_hash}->{$hash}->{subject}\n";
            sync_head($commits);
            run_command("git cherry-pick --allow-empty --allow-empty-message --ff $hash");
        }
    } elsif ($commits->{head}->{type} eq "synced") {
        run_command("git cherry-pick --allow-empty --allow-empty-message --ff $hash");
    } else {
        confess("Unknown head type: $commits->{head}->{type}");
    }
}

sub comment($) { my ($comment) = @_;
    write_file("$GIT_DIR/rebase2/commit_msg", $comment);
    run_command("git commit --amend -F \"$GIT_DIR/rebase2/commit_msg\"");
}

sub build_rebase_sequence($$$$) { my ($commits, $from, $to, $through) = @_;
    my @result;
    my $prev_hash = $from;
    my $sequence = find_sequence($commits->{by_hash}, $from, $to, $through);
    my %marks = ( $from => undef );
    @marks{@{$sequence}} = ();
    my $mark_num = 1;
    foreach my $step_hash (@{$sequence}) {
        foreach my $parent (grep { $_ ne $prev_hash; } @{$commits->{by_hash}->{$step_hash}->{parents}}) {
            if (exists $marks{$parent} && !defined $marks{$parent}) {
                $marks{$parent} = "tmp_" . $mark_num;
                $mark_num++;
            }
        }
        $prev_hash = $step_hash;
    }
    if (defined $marks{$from}) {
        push @result, { type => 'mark', name => $marks{$from} };
    }
    my $prev_hash = $from;
    foreach my $step_hash (@{$sequence}) {
        if (!grep { $_ eq $prev_hash; } @{$commits->{by_hash}->{$step_hash}->{parents}}) {
            foreach my $new_prev (grep { exists $marks{$_}; } @{$commits->{by_hash}->{$step_hash}->{parents}}) {
                confess ("Unresolved mark for $new_prev") if (!defined $marks{$new_prev});
                push @result, { type => "reset", ahash => "\@$marks{$new_prev}" };
                $prev_hash = $new_prev;
                last;
            }
        }
        if (scalar @{$commits->{by_hash}->{$step_hash}->{parents}} == 1) {
            push @result, { type => 'pick', ahash => $commits->{by_hash}->{$step_hash}->{ahash} };
            if (defined $marks{$step_hash}) {
                push @result, { type => 'mark', name => $marks{$step_hash} };
            }
        } else {
            push @result, make_merge_steps($step_hash, $prev_hash, $commits, \%marks);
        }
        $prev_hash = $step_hash;
    }
    return \@result;
}

# TODO: tests, tests, tests
sub make_merge_steps($$$$) { my ($step_hash, $prev_hash, $commits, $marks) = @_;
    find_only($prev_hash, @{$commits->{by_hash}->{$step_hash}->{parents}});
    my @parents_ahashes = map {
        if ($_ eq $prev_hash) {
            "HEAD";
        } elsif (exists $marks->{$_}) {
            confess ("Unresolved mark for $_") if (!defined $marks->{$_});
            "\@$marks->{$_}";
        } elsif (exists $commits->{by_hash}->{$_}) {
            $commits->{by_hash}->{$_}->{ahash};
        } else {
            my $ahash = read_popen("git show -s --pretty=format:%h $_ --");
        }
    } @{$commits->{by_hash}->{$step_hash}->{parents}};
    my %merge_flags;
    if (system("git diff --quiet $step_hash $commits->{by_hash}->{$step_hash}->{parents}->[0]") == 0) {
        $merge_flags{ours} = 1;
    }
    my $ahash = $commits->{by_hash}->{$step_hash}->{ahash};
    return { type => "merge", ahash => $ahash, parents => \@parents_ahashes, flags => \%merge_flags };
}

sub git_resolve_hashes($) { my ($refs) = @_;
    foreach (@{$refs}) { verify_cmdarg($_); }
    my $refs_str = join " ", @{$refs};
    my @result = ();
    iterate_popen {
        s/^\s+|\s+$//g;
        push @result, $_;
    } "git rev-parse $refs_str";
    confess("Hash number does not match") unless (scalar @result == scalar @{$refs});
    return @result;
}

sub git_fetch_commits($$) { my ($from, $to) = @_;
    verify_cmdarg($from);
    verify_cmdarg($to);
    my $commits = {by_hash => {}, refs => {}, marks => {}};
    open(my $in, ">", "$GIT_DIR/rebase2/commits") or confess("Cannot write commits cache ($GIT_DIR/rebase2/commits): $!");
    iterate_popen {
        git_parse_commit_line($commits, $_);
        printf($in "%s", $_) or confess("Cannot write commits cache ($GIT_DIR/rebase2/commits): $!");
    } "git log --ancestry-path --pretty=format:%H:%h:%P:%s $from..$to";
    close($in) or confess("Cannot write commits cache ($GIT_DIR/rebase2/commits): $!");
    return $commits;
}

sub git_load_commits() {
    my $commits = {by_hash => {}, refs => {}};
    iterate_file { git_parse_commit_line($commits, $_); } "$GIT_DIR/rebase2/commits";
    if (-e "$GIT_DIR/rebase2/marks") {
        iterate_file {
            if (/^([0-9a-zA-Z_\/]+) ([0-9a-fA-F]+)$/) {
                $commits->{marks}->{$1} = $2;
            } else {
                confess("Invalid mark line: $_");
            }
        } "$GIT_DIR/rebase2/marks";
    }
    return $commits;
}

sub git_parse_commit_line($$) { my ($commits, $line) = @_;
    if ($line =~ /^([0-9a-f]+):([0-9a-f]+):([0-9a-f ]*):(.*)\x{a}?$/) {
        my $hash = $1;
        my $ahash = $2;
        my @parents = split(/ /, $3);
        my $subject = $4;
        verify_hash($hash);
        foreach my $p (@parents) { verify_hash($p); }
        if (!exists $commits->{by_hash}->{$hash}) {
            my $obj = {parents => \@parents, subject => $subject, hash => $hash, ahash => $ahash};
            $commits->{by_hash}->{$hash} = $obj;
        }
        if (exists $commits->{refs}->{$ahash}) {
            if ($commits->{refs}->{$ahash} ne $hash) {
                confess("duplicated ref with different hash: $ahash => $hash, $commits->{refs}->{$ahash}");
            }
        } else {
            $commits->{refs}->{$ahash} = $hash;
        }
    } else {
        confess("Could not parse line: $line");
    }
}

sub git_merge_base($$) { my ($b1, $b2) = @_;
    verify_cmdarg($b1);
    verify_cmdarg($b2);
    my $result = "";
    my $hit = 0;
    iterate_popen {
        s/^\s+|\s+$//g;
        if (!$hit) {
            $result = $_;
            $hit = 1;
        } else {
            confess "Multiple merge-bases for $b1 and $b2";
        }
    } "git merge-base -a $b1 $b2";
    if (!$hit) {
        confess "Merge-base not found for $b1 and $b2"
    }
    return $result;
}

sub git_sequence_editor() {
    if (exists $ENV{GIT_SEQUENCE_EDITOR}) {
        return $ENV{GIT_SEQUENCE_EDITOR};
    }

    foreach my $cmd ("git config sequence.editor || true", "git var GIT_EDITOR || true") {
        my $git_editor = read_popen($cmd);
        if ($git_editor ne "") {
            return $git_editor;
        }
    }

    confess ("Editor not found");
}

sub run_command($) { my ($command) = @_;
    my $ret = system($command);
    confess("Command failed: $ret") unless ($ret == 0);
}

sub read_popen($) { my ($command) = @_;
    my $res = "";
    iterate_popen { $res .= $_; } $command;
    $res =~ s/^\s+|\s+$//g;
    return $res;
}

sub verify_hash($) { my ($str) = @_;
    # allow abbreviated
    if ($str !~ /^[0-9a-f]{40}$/) {
        confess "Invalid hash: $str";
    }
}

sub verify_cmdarg($) { my ($str) = @_;
    if ($str =~ /["'\\\(\)#]|[\x00- ]/) {
        confess "Invalid cmdarg: $str";
    }
}

sub init_save($$) { my ($target_ref, $initial_branch) = @_;
    if (-e "$GIT_DIR/rebase2") {
        confess "already in progress?";
    }
    mkdir("$GIT_DIR/rebase2") or confess "Mkdir $GIT_DIR/rebase2 failed: $!";
    write_file("$GIT_DIR/rebase2/target_ref", $target_ref);
    write_file("$GIT_DIR/rebase2/initial_branch", $initial_branch);
}

sub cleanup_save() {
    # will throw itself
    rmtree("$GIT_DIR/rebase2");
}

sub commits_get_subject($$) { my ($commits, $ref) = @_;
    # TODO: not existing keys be assertions as soon as reading of unknown commits is imlemented
    if (!exists $commits->{refs}->{$ref}) {
        return "???";
    }
    my $hash = $commits->{refs}->{$ref};
    if (!exists $commits->{by_hash}->{$hash}) {
        return "???";
    }
    return $commits->{by_hash}->{$hash}->{subject};
}

sub save_todo($$$) { my ($todo, $file, $commits) = @_;
    with_output_file($file, sub { my ($out) = @_;
        foreach my $step (@{$todo}) {
            if ($step->{type} eq "pick") {
                print $out "pick $step->{ahash} " . commits_get_subject($commits, $step->{ahash}) . "\n";
            } elsif ($step->{type} eq "edit") {
                print $out "edit $step->{ahash} " . commits_get_subject($commits, $step->{ahash}) . "\n";
            } elsif ($step->{type} eq "fixup") {
                print $out "fixup $step->{ahash} " . commits_get_subject($commits, $step->{ahash}) . "\n";
            } elsif ($step->{type} eq "reset") {
                print $out "reset $step->{ahash}\n";
            } elsif ($step->{type} eq "exec") {
                if ($step->{command} =~ /\n/) {
                    confess "multiline command cannot be saved";
                }
                print $out "exec $step->{command}\n";
            } elsif ($step->{type} eq "comment") {
                print $out "comment\n";
                write_todo_comment($out, $step->{comment});
            } elsif ($step->{type} eq "merge") {
                my $flags_str = "";
                if ($step->{flags}->{ours}) {
                    $flags_str .= " --ours"
                }
                my $parents_str2 = join ",", @{$step->{parents}};
                my $subject = "";
                if (exists $step->{ahash}) {
                    $flags_str .= " -c $step->{ahash}";
                    $subject = " " . commits_get_subject($commits, $step->{ahash});
                }
                print $out "merge$flags_str $parents_str2$subject\n";
            } elsif ($step->{type} eq "mark") {
                print $out ": $step->{name}\n";
            } else {
                confess "Type $step->{type} is unknown or not implemented";
            }
        }
    });
}

sub write_todo_comment($$) { my ($out, $comment) = @_;
    while ($comment =~ /\n\.\n/) {
        $comment =~ s/\n\.\n/\n/;
    }
    print $out "$comment";
    if (substr($comment, -1) ne "\n") {
        print $out "\n";
    }
    print $out ".\n";
}

sub default_error($) { my ($msg) = @_;
    confess($msg);
}

# TODO for caching refs
# * add to commits aliases (refs, whatever), which map entered aliases to commits
# * save and restore them to something like rebase2/commit_refs
# * refer to the refs dictionary in read_todo()
# * fill missing refs and missing commits in the following function
# * consider splitting the resolving part; I believe it should be possible to handle all state in todo+commits
#   * describe the data structure
# * use git_resolve_hashes() for resolving refs, git show ... for getting info

sub read_todo($$;\$) { my ($filename, $commits, $errorHandler) = @_;
    my $onSyntaxError = (defined $errorHandler && exists $errorHandler->{onSyntaxError}) ? $errorHandler->{onSyntaxError} : \&default_error ;
    my $todo = [];
    open(my $in, "<", $filename) or confess "Cannot open file $filename: $!";
    my $mode = "COMMAND";
    my $comment = undef;
    while (<$in>) {
        if ($mode eq "COMMAND") {
            if (/^#.*$/) {
            } elsif (/^(f|fixup) (\@?[0-9a-zA-Z_\/]+)( (.*))?$/) {
                push @{$todo}, {type => "fixup", ahash => $2};
            } elsif (/^(p|pick) (\@?[0-9a-zA-Z_\/]+)( (.*))?$/) {
                push @{$todo}, {type => "pick", ahash => $2};
            } elsif (/^(e|edit) (\@?[0-9a-zA-Z_\/]+)( (.*))?$/) {
                push @{$todo}, {type => "edit", ahash => $2};
            } elsif (/^(reset) (\@?[0-9a-zA-Z_\/]+)?$/) {
                push @{$todo}, {type => "reset", ahash => $2};
            } elsif (/^(x|exec) (.+)$/) {
                push @{$todo}, {type => "exec", command => $2};
            } elsif (/^comment\b/) {
                $mode = "COMMENT";
                $comment = "";
            } elsif (/^merge( --ours| -c \@?[0-9a-zA-Z_\/]+)* (.+[^\n\r ])$/) {
                my $pos_string = $2;
                # TODO: verify as refs
                my $ahash = undef;
                my $flags = {};
                my @options = split / +/,$1;
                while (scalar @options > 0) {
                    if (shift @options eq "--ours") {
                        $flags->{ours} = 1;
                    } elsif (scalar @options > 1 && shift @options eq "-c") {
                        $ahash = shift @options;
                    } else {
                        onSyntaxError->("Unexpected merge options: " . join @options);
                    }
                }
                my @pos_args = split / +/, $pos_string, 2;
                my $parents = [split /,/, $pos_args[0]];
                my $step = {type => "merge", parents => $parents, flags => $flags};
                if (defined $ahash) {
                    $step->{ahash} = $ahash;
                }
                push @{$todo}, $step;
            } elsif (/^: ([^\n\r ]+)$/) {
                my $name = $1;
                if ($name =~ /[^0-9a-z_]/i) {
                    $onSyntaxError->("Dangerous symbols in mark name: $name");
                }
                push @{$todo}, {type => "mark", name => $name};
            } elsif (/^[[:space:]]*$/) {
            } else {
                s/\n//;
                $onSyntaxError->("Unrecognised todo line for mode $mode: \"$_\"");
            }
        } elsif ($mode eq "COMMENT") {
            if (/^#.*$/) {
            } elsif (/^\.$/) {
                $mode = "COMMAND";
                push @{$todo}, {type => "comment", comment => $comment};
            } else {
                $comment = $comment . $_;
            }
        } else {
            $onSyntaxError->("Unexpected mode: $mode");
        }
    }
    close($in);
    if ($mode ne "COMMAND") {
        $onSyntaxError->("Unterminated comment");
    }
    # TODO: resolve the $unknown_commits
    return $todo;
}

sub with_output_file($$) { my ($filename, $proc) = @_;
    if (ref $filename eq "") {
        open(my $out, ">", $filename + ".new") or confess "Cannot open file $filename.new: $!";
        $proc->($out);
        close($out) or confess "Cannot close output file $filename.new: $!";
        rename($filename + ".new", $filename) or "Cannot replace output file $filename: $!";
    } else {
        # for testing
        open(my $out, ">", $filename) or confess "Cannot open file $filename: $!";
        $proc->($out);
        close($out) or confess "Cannot close output file $filename.new: $!";
    }
}

sub write_file($$) { my ($filename, $str) = @_;
    with_output_file($filename, sub { my ($out) = @_;
        print $out $str;
    });
}

sub read_file($) { my ($filename) = @_;
    open(my $out, "<", $filename) or confess "Cannot open file $filename: $!";
    my $data = "";
    if (read($out, $data, 1024) <= 0) {
        confess "Read failed: $!";
    }
    close($out) or confess "Cannot close file $filename: $!";
    return $data;
}

sub get_single(\@) { my ($array) = @_;
    if (scalar @{$array} != 1) {
        confess ("Should be an array with single element: " . Dumper($array));
    }
    return $array->[0];
}


# $commits : { $hash => { parents => [ $hash ] } }
# returns: [ $hash ]
sub find_sequence($$$$) { my ($commits, $from, $to, $through_list) = @_;
    # deep-first search, coroutine-based approach
    # fun X($v)
    #  do in loop:
    #   if $v == $from - stop and return the sequence (**)
    #   if 0 parents - stop
    #   if >1 children - pause and wait until all children are processed.
    #    add their output to the end of the sequence and continue
    #   if >1 children and you are not 1st - mark the children you came by as processed and store your sequence (*), then stop
    #   otherwise add the current to sequence
    #   fork itself for each parent, continuing the sequence
    # (*) store only the portion which is not yet in the sequence. Looks like it should be enough just to filter it
    # (**) here several returns should be sorted out

    # thread info:
    # { state => "READY" | "WAIT_CHILDREN" | "DONE",
    #   current => String,
    #   todo => [ String ] }
    # copied while forking
    # children_waiters = { $hash => { todo_index => { String => () }, left => num, thread => ref to thread } }
    # children_num => { $hash => num }

    my %children_num = ();
    foreach my $h (keys %{$commits}) {
        $children_num{$h} = 0;
    }
    $children_num{$from} = 0;
    $children_num{$to} = 0;
    # fill children_total for each commit
    foreach my $h (keys %{$commits}) {
        foreach my $p (@{$commits->{$h}->{parents}}) {
            if (exists $children_num{$p}) {
                $children_num{$p}++;
            } else {
                $children_num{$p} = 1;
            }
        }
    }
    my %children_waiters = ();
    my @schedule = ({ state => "READY", current => $to, todo => []});

    # FIXME: very slow, just to make it work
    # non-branching regions should be recorded without recreating
    # TODO: case of throughs in several branches is not covered
    while (scalar @schedule > 0 && $schedule[0]->{state} ne "DONE") {
        my $i = 0;
        while ($schedule[$i]->{state} ne "READY") {
            confess("No thread is READY") if ($i >= scalar @schedule);
            ++$i;
        }

        my $hash = $schedule[$i]->{current};
        if ($hash eq $from) {
            $schedule[$i]->{state} = "DONE";
            my %todo_index = ();
            @todo_index{@{$schedule[$i]->{todo}}} = ();
            if ((grep { !exists $todo_index{$_}; } @{$through_list}) > 0) {
                splice @schedule, $i, 1, ();
            }
        } elsif ($children_num{$hash} > 1 && (!exists $children_waiters{$hash} || $children_waiters{$hash}->{left} != 0)) {
            if (exists $children_waiters{$hash}) {
                foreach my $step (@{$schedule[$i]->{todo}}) {
                    if (!exists $children_waiters{$hash}->{todo_index}->{$step}) {
                        push @{$children_waiters{$hash}->{thread}->{todo}}, $step;
                        $children_waiters{$hash}->{todo_index}->{$step} = undef;
                    }
                }
                $children_waiters{$hash}->{left}--;
                if ($children_waiters{$hash}->{left} == 0) {
                    $children_waiters{$hash}->{thread}->{state} = "READY";
                }
                splice @schedule, $i, 1, ();
            } else {
                my %todo_index = ();
                @todo_index{@{$schedule[$i]->{todo}}} = ();
                $children_waiters{$hash} = { todo_index => \%todo_index,
                                              left => $children_num{$hash} - 1,
                                              thread => $schedule[$i] };
                $schedule[$i]->{state} = "WAIT_CHILDREN";
            }
        } else {
            push @{$schedule[$i]->{todo}}, $hash;
            my @new_tasks = map {
                { state => "READY", current => $_, todo => [ @{$schedule[$i]->{todo}} ] };
            } @{$commits->{$hash}->{parents}};
            splice @schedule, $i, 1, @new_tasks;
        }
    }

    if (scalar @schedule > 0) {
        return [ reverse @{$schedule[0]->{todo}} ];
    } else {
        confess("No path found");
    }
}

# TODO: options parser
# * interactive
# * continue, abort

if ($0 !~ /test\.pl/) {
    eval { main(\@ARGV); };
    if ($@ ne "") {
        print "Error: $@";
        exit(1);
    }
}
