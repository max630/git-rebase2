#!/usr/bin/env perl

use strict;

use Data::Dumper;
use Carp;
use File::Path qw(rmtree);
use File::Temp qw(:mktemp);

sub main ($) { my @argv = @{$_[0]};
    my $interactive = 0;
    while (1) {
        if (0) {
        } elsif ($argv[0] eq "-i" || $argv[0] eq "--interactive") {
            $interactive = 1;
            shift @argv;
        } elsif ($argv[0] eq "--abort") {
            confess ("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. -1]) . "\"") if (scalar @argv > 1);
            abort_rebase();
            return;
        } elsif ($argv[0] eq "--skip") {
            confess ("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. -1]) . "\"") if (scalar @argv > 1);
            my ($todo, $current, $commits, $target_ref) = restore_rebase();
            if ($current) {
                run_command("git reset --hard HEAD");
                unlink(".git/rebase2/current");
            }
            run_rebase($todo, $commits, $target_ref);
            return;
        } elsif ($argv[0] eq "--continue") {
            confess ("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. -1]) . "\"") if (scalar @argv > 1);
            my ($todo, $current, $commits, $target_ref) = restore_rebase();
            if ($current) {
                run_continue($current, $commits);
                unlink(".git/rebase2/current");
            }
            run_rebase($todo, $commits, $target_ref);
            return;
        # } elsif (scalar @argv == 1) { TODO: find HEAD?
        } elsif (scalar @argv == 2) {
            my ($dest, $source_to) = @argv;
            my ($todo, $commits, $target_ref) = init_rebase($dest, $source_to);
            if ($interactive) {
                ($todo, $commits) = edit_todo($todo, $commits);
            }
            run_rebase($todo, $commits, $target_ref);
            return;
        } else {
            confess ("Invalid arguments: \"" . join(" ", @argv) . "\"");
        }
    }
}

sub restore_rebase() {
    my $target_ref = read_file(".git/rebase2/target_ref");
    my ($todo, $commits) = read_todo(".git/rebase2/todo");
    my $current = 0;
    if (-e ".git/rebase2/current") {
        my @current_todo = read_todo(".git/rebase2/current");
        $current = get_single($current_todo[0]);
    }
    return ($todo, $current, $commits, $target_ref);
}

sub init_rebase($$) { my ($dest, $source_to) = @_;
    my $target_ref = $source_to;
    my $source_from = git_merge_base($dest, $source_to);
    #print Dumper($dest, $source_from, $source_to, $target_ref);
    #TODO: resolve all arguments
    my ($dest_hash, $source_from_hash, $source_to_hash) = git_resolve_hashes([$dest, $source_from, $source_to]);
    my $commits = git_fetch_commits($source_from, $source_to);
    my $todo = build_rebase_sequence($commits, $source_from_hash, $source_to_hash);
    init_save($target_ref);
    # TODO: edit if interactive
    run_command("git checkout --quiet --detach $dest_hash");
    return ($todo, $commits, $target_ref);
}

sub edit_todo($$) { my ($old_todo, $old_commits) = @_;
    my ($tmpfh, $tmpname) = mkstemp(".git/rebase2/todo.XXXXXXXX");
    # TODO: write without reopen, to fh
    close($tmpfh) or confess ("Unable to close the tmpfile");
    save_todo($old_todo, $tmpname, $old_commits);
    run_command(git_sequence_editor() . " $tmpname");
    my ($new_todo, $new_commits) = read_todo($tmpname);
    return ($new_todo, $new_commits);
}

sub run_continue($$) { my ($current, $commits) = @_;
    run_command("git rev-parse --verify HEAD >/dev/null"
                . " && git update-index --ignore-submodules --refresh"
                . " && git diff-files --quiet --ignore-submodules");
    # TODO: restore proper rebase-like behavior
    if ($current->{type} eq "pick") {
        if (system("git diff-index --quiet --ignore-submodules --cached HEAD") == 0) {
            # commited already
        } else {
            run_command("git commit -c $current->{ahash}");
        }
    } elsif ($current->{type} eq "fixup") {
        if (system("git diff-index --quiet --ignore-submodules --cached HEAD") == 0) {
            # commited already
        } else {
            run_command("git commit --amend");
        }
    } elsif ($current->{type} eq "comment") {
        comment($current->{comment});
    } else {
        confess "Type $current->{type} is unknown or not implemented";
    }
}

sub run_rebase($$$) { my ($todo, $commits, $target_ref) = @_;
    # TODO: handle errors
    while (defined (my $current = shift @{$todo})) {
        save_todo($todo, ".git/rebase2/todo", $commits);
        save_todo([$current], ".git/rebase2/current", $commits);
        run_step($current, $commits);
        unlink(".git/rebase2/current");
    }
    # TODO: make proper reflog
    run_command("git checkout -B $target_ref");
    cleanup_save();
}

sub abort_rebase() {
    my $target_ref = read_file(".git/rebase2/target_ref");
    run_command("git reset --hard $target_ref");
    run_command("git checkout -f $target_ref");
    cleanup_save();
}

sub run_step($) { my ($rebase_step, $commits) = @_;
    if ($rebase_step->{type} eq "pick") {
        print "Apply: $commits->{by_ahash}->{$rebase_step->{ahash}}->{subject}\n";
        pick($rebase_step->{ahash});
    } elsif ($rebase_step->{type} eq "fixup") {
        print "Fixup: $commits->{by_ahash}->{$rebase_step->{ahash}}->{subject}\n";
        run_command("git cherry-pick --allow-empty --allow-empty-message --no-commit $rebase_step->{ahash} "
                    . "&& git commit --amend --no-edit");
    } elsif ($rebase_step->{type} eq "comment") {
        print "Updating comment\n";
        comment($rebase_step->{comment});
    } elsif ($rebase_step->{type} eq "merge") {
        print "Merging\n";
        # to merge as non-first child:
        # 1. get the current position
        # 2. reset to the first child
        my $command = "git merge --no-edit";
        if ($rebase_step->{flags}->{ours}) {
            $command .= " --strategy=ours";
        }
        my @parents = @{$rebase_step->{parents}};
        my $head_pos = find_only("HEAD", \@parents);
        if ($head_pos != 0) {
            # TODO: how to handle it in skip?
            # TODO: dont forget to make sure all parents are good cli args
            $parents[$head_pos] = git_resolve("HEAD");
            run_command("git reset --hard $parents[0]");
        }
        shift @parents;
        foreach my $p (@parents) {
            $command .= " $p";
        }
        run_command($command);
        comment($rebase_step->{comment});
    } else {
        confess "Type $rebase_step->{type} is unknown or not implemented";
    }
}

sub find_only ($\@) { my ($needle, $items) = @_;
    my $result = -1;
    my $pos = 0;
    foreach my $item (@{$items}) {
        if ($item eq $needle) {
            if ($result != -1) {
                confess("Duplicated $needle");
            } else {
                $result = $pos;
            }
        }
        ++$pos;
    }
    if ($result == -1) {
        confess("Not found: $needle");
    }
    return $result;
}

sub pick($) { my ($hash) = @_;
    # TODO: clear out all details
    run_command("git cherry-pick --allow-empty --allow-empty-message --ff $hash");
}

sub comment($) { my ($comment) = @_;
    write_file(".git/rebase2/commit_msg", $comment);
    run_command("git commit --amend -F .git/rebase2/commit_msg");
}

sub build_rebase_sequence($$) { my ($commits, $from, $to) = @_;
    my @result;
    my $step_hash = $from;
    foreach my $step_hash (@{find_sequence($commits->{by_hash}, $from, $to, [])}) {
        if (scalar @{$commits->{by_hash}->{$step_hash}->{parents}} == 1) {
            push @result, { type => 'pick', ahash => $commits->{by_hash}->{$step_hash}->{ahash} };
        } else {
            push @result, make_merge_steps($step_hash, $prev_hash, $commits);
        }
        $prev_hash = $step_hash;
    }
    return \@result;
}

# TODO: tests, tests, tests
sub make_merge_steps($$\%) { my ($step_hash, $prev_hash, $commits) = @_;
    my $head_idx = find_only($prev_hash, $commits->{by_hash}->{$step_hash}->{parents});
    my @parents_ahashes = map {
        if (exists $commits->{by_hash}->{$_}) {
            $commits->{by_hash}->{$_}->{ahash};
        } else {
            my ($ahash) = git_resolve_hashes([$_]);
        }
    } $commits->{by_hash}->{$step_hash}->{parents};
    my %merge_flags;
    if (system("git diff --quiet $step_hash $parents_ahashes->[$head_idx]") == 0) {
        $merge_flags{ours} = 1;
    }
    $parents_ahashes->[$head_idx] = "HEAD";
    my $comment = "";
    iterate_popen("git log --max-count=1 --pretty=format:%B $step_hash", sub { $comment .= $_; });
    return { type => "merge", comment => $comment, parents => $parents_ahashes, flags => \%merge_flags };
}

sub git_resolve_hashes($) { my ($refs) = @_;
    foreach (@{$refs}) { verify_cmdarg($_); }
    my $refs_str = join " ", @{$refs};
    my @result = ();
    iterate_popen("git rev-parse $refs_str", sub {
        s/^\s+|\s+$//g;
        push @result, $_;
    });
    confess("Hash number does not match") unless ($#result == $#{$refs});
    return @result;
}

sub git_fetch_commits($$) { my ($from, $to) = @_;
    verify_cmdarg($from);
    verify_cmdarg($to);
    my $commits = {by_hash => {}, by_ahash => {}};
    # TODO: abbreviated hashes should really be used some day,
    # but this needs care
    # looks like git dynamically decides length for each hash,
    # so probably need indexing rather than just substring.
    # Or do it other way around? Don't know...
    iterate_popen("git log --ancestry-path --pretty=format:%H:%h:%P:%s $from..$to",
                  sub {
        if (/^([0-9a-f]+):([0-9a-f]+):([0-9a-f ]*):(.*)\x{a}?$/) {
            my $hash = $1;
            my $ahash = $2;
            my @parents = split(/ /, $3);
            my $subject = $4;
            verify_hash($hash);
            foreach my $p (@parents) { verify_hash($p); }
            if (exists $commits->{by_hash}->{$hash} || exists $commits->{by_ahash}->{$ahash}) {
                confess "Duplicated commit: $hash ($ahash)";
            }
            my $obj = {parents => \@parents, subject => $subject, hash => $hash, ahash => $ahash};
            $commits->{by_hash}->{$hash} = $obj;
            $commits->{by_ahash}->{$ahash} = $obj;
        } else {
            confess("Could not parse line: $_");
        }
    });
    return $commits;
}

sub git_merge_base($$) { my ($b1, $b2) = @_;
    verify_cmdarg($b1);
    verify_cmdarg($b2);
    my $result = "";
    my $hit = 0;
    iterate_popen("git merge-base -a $b1 $b2", sub {
        s/^\s+|\s+$//g;
        if (!$hit) {
            $result = $_;
            $hit = 1;
        } else {
            confess "Multiple merge-bases for $b1 and $b2";
        }
    });
    if (!$hit) {
        confess "Merge-base not found for $b1 and $b2"
    }
    return $result;
}

sub git_sequence_editor() {
    if (exists $ENV{GIT_SEQUENCE_EDITOR}) {
        return $ENV{GIT_SEQUENCE_EDITOR};
    }

    my $git_editor = "";
    foreach my $cmd ("git config sequence.editor", "git var GIT_EDITOR") {
        iterate_popen("git var GIT_EDITOR", sub {
            $git_editor = $git_editor . $_;
        });
        $git_editor =~ s/^\s+|\s+$//g;
        if ($git_editor ne "") {
            return $git_editor;
        }
    }

    confess ("Editor not found");
}

sub run_command($) { my ($command) = @_;
    my $ret = system($command);
    confess("Command failed: $ret") unless ($ret == 0);
}

sub iterate_popen($$) { my ($command, $code) = @_;
    open(my $in, "-|", $command) or confess "Cannot start a program: $!";
    while (<$in>) {
        $code->($_);
    }
    close ($in) or confess "Program failed";
}

sub verify_hash($) { my ($str) = @_;
    # allow abbreviated
    if ($str !~ /^[0-9a-f]{40}$/) {
        confess "Invalid hash: $str";
    }
}

sub verify_cmdarg($) { my ($str) = @_;
    if ($str =~ /["'\\\(\)#]|[\x00- ]/) {
        confess "Invalid cmdarg: $str";
    }
}

sub init_save($) { my ($target_ref) = @_;
    if (-e ".git/rebase2") {
        confess "already in progress?";
    }
    mkdir(".git/rebase2") or confess "Mkdir .git/rebase2 failed: $!";
    write_file(".git/rebase2/target_ref", $target_ref);
}

sub cleanup_save() {
    # will throw itself
    rmtree(".git/rebase2");
}

sub save_todo($$$) { my ($todo, $file, $commits) = @_;
    with_output_file($file, sub { my ($out) = @_;
        foreach my $step (@{$todo}) {
            if ($step->{type} eq "pick") {
                print $out "pick $step->{ahash} $commits->{by_ahash}->{$step->{ahash}}->{subject}\n";
            } elsif ($step->{type} eq "fixup") {
                print $out "fixup $step->{ahash} $commits->{by_ahash}->{$step->{ahash}}->{subject}\n";
            } elsif ($step->{type} eq "comment") {
                print $out "comment\n";
                write_todo_comment($out, $step->{comment});
            } elsif ($step->{type} eq "merge") {
                my $flags_str = "";
                if ($step->{flags}->{ours}) {
                    $flags_str .= " --ours"
                }
                my $parents_str = join " ", @{$step->{parents}};
                print $out "comment$flags_str $parents_str\n";
                write_todo_comment($out, $step->{comment});
            } else {
                confess "Type $step->{type} is unknown or not implemented";
            }
        }
    });
}

sub write_todo_comment($$) { my ($out, $comment) = @_;
    while ($comment =~ /\n\.\n/) {
        $comment =~ s/\n\.\n/\n/;
    }
    print $out "$comment";
    if (substr($comment, -1) ne "\n") {
        print $out "\n";
    }
    print $out ".\n";
}

sub read_todo($) { my ($filename) = @_;
    my $todo = [];
    my $commits = {by_ahash => {}};
    open(my $in, "<", $filename) or confess "Cannot open file $filename: $!";
    my $mode = "COMMAND";
    my $comment = "";
    my %merge_flags;
    my @merge_parents;
    while (<$in>) {
        if ($mode eq "COMMAND") {
            if (/^#.*$/) {
            } elsif (/^fixup ([0-9a-f]+) (.*)$/) {
                push @{$todo}, {type => "fixup", ahash => $1};
                if (!exists $commits->{by_ahash}->{$1}) {
                    # duplicates are in principle acceptable
                    $commits->{by_ahash}->{$1} = {subject => $2};
                }
            } elsif (/^pick ([0-9a-f]+) (.*)$/) {
                push @{$todo}, {type => "pick", ahash => $1};
                if (!exists $commits->{by_ahash}->{$1}) {
                    # duplicates are in principle acceptable
                    $commits->{by_ahash}->{$1} = {subject => $2};
                }
            } elsif (/^comment\b/) {
                $mode = "COMMENT";
                $comment = "";
            } elsif (/^merge( --ours)? (.+[^\n\r ])$/) {
                $mode = "MERGE_COMMENT";
                $comment = "";
                @merge_parents = split / +/, $2;
                # TODO: verify as refs
                %merge_flags = ();
                if ($1) {
                    $merge_flags{ours} = 1;
                }
            } elsif (/^[[:space:]]*$/) {
            } else {
                confess "Unrecognised todo line for mode $mode: \"$_\"";
            }
        } elsif ($mode eq "COMMENT") {
            if (/^#.*$/) {
            } elsif (/^\.$/) {
                $mode = "COMMAND";
                push @{$todo}, {type => "comment", comment => $comment};
            } else {
                $comment = $comment . $_;
            }
        } elsif ($mode eq "MERGE_COMMENT") {
            if (/^#.*$/) {
            } elsif (/^\.$/) {
                $mode = "COMMAND";
                push @{$todo}, {type => "merge", comment => $comment, parents => \@merge_parents, flags => \%merge_flags};
            } else {
                $comment = $comment . $_;
            }
        } else {
            confess "Unexpected mode: $mode";
        }
    }
    close($in);
    if ($mode ne "COMMAND") {
        confess "Unterminated comment";
    }
    return ($todo, $commits);
}

sub with_output_file($$) { my ($filename, $proc) = @_;
    open(my $out, ">", $filename + ".new") or confess "Cannot open file $filename.new: $!";
    $proc->($out);
    close($out) or confess "Cannot close output file $filename.new: $!";
    rename($filename + ".new", $filename) or "Cannot replace output file $filename: $!";
}

sub write_file($$) { my ($filename, $str) = @_;
    with_output_file($filename, sub { my ($out) = @_;
        print $out $str;
    });
}

sub read_file($) { my ($filename) = @_;
    open(my $out, "<", $filename) or confess "Cannot open file $filename: $!";
    my $data = "";
    if (read($out, $data, 1024) <= 0) {
        confess "Read failed: $!";
    }
    close($out) or confess "Cannot close file $filename: $!";
    return $data;
}

sub get_single(\@) { my ($array) = @_;
    if (scalar @{$array} != 1) {
        confess ("Should be an array with single element: " . Dumper($array));
    }
    return $array->[0];
}


# $commits : { $hash => { parents => [ $hash ] } }
sub find_sequence($$$$) { my ($commits, $from, $to, $through_list) = @_;
    # TODO:
    # + through
    # + explicitly forbid inner merges
    # * inner merges
    #  * interface
    #  * extraction

    # initialize data
    my %through_hash = ();
    @through_hash{@{$through_list}} = ();
    my %commitsX = ();
    foreach my $h (keys %{$commits}) {
        $commitsX{$h} = { children_count => 0, children => [] };
    }
    $commitsX{$from} = { children_count => 0, children => [] };
    $commitsX{$to} = { children_count => 0, children => [], cost => [0, {}] };
    # fill children_count for each commit
    foreach my $h (keys %{$commits}) {
        foreach my $p (@{$commits->{$h}->{parents}}) {
            if (exists $commitsX{$p}) {
                $commitsX{$p}->{children_count}++;
            }
        }
    }
    # main step - mark each commit with cost and best child
    my %edge = ($to => 1);
    while (scalar %edge) {
        my %next_edge = ();
        foreach my $v (keys %edge) {
            my $vertex_cost = $commitsX{$v}->{cost};
            foreach my $p (@{$commits->{$v}->{parents}}) {
                push(@{$commitsX{$p}->{children}}, $v);
                if (scalar @{$commitsX{$p}->{children}} == $commitsX{$p}->{children_count}) {
                    # all children are filled, find the best one
                    my ($min_cost, $min_child) = find_minimal_cost(map { [$commitsX{$_}->{cost}, $_] } @{$commitsX{$p}->{children}});
                    $commitsX{$p}->{cost} = [$min_cost->[0] + 1, $min_cost->[1]];
                    if (exists $through_hash{$p}) {
                        my %new_set = %{$commitsX{$p}->{cost}->[1]};
                        $new_set{$p} = ();
                        $commitsX{$p}->{cost}->[1] = \%new_set;
                    }
                    $commitsX{$p}->{sequence_child} = $min_child;
                    $next_edge{$p} = 1;
                }
            }
        }
        %edge = %next_edge;
    }
    # collect the path by child marks
    my @res = ();
    my $next = $from;
    while ($next ne $to) {
        $next = $commitsX{$next}->{sequence_child};
        if ($commitsX{$next}->{children_count} > 1) {
            confess("inner merges not supported yet (found in commit $next)");
        }
        push @res, $next;
    }
    return \@res;
}

sub find_minimal_cost(@) {
    my @result = (undef, undef);
    foreach my $item (@_) {
        if (!defined $result[0] || do {
                my ($result_cost, $result_marks) = @{$result[0]};
                my ($item_cost, $item_marks) = @{$item->[0]};
                if (is_subset($result_marks, $item_marks)) {
                    if (is_subset($item_marks, $result_marks)) {
                        # they are equal
                        $result_cost > $item_cost;
                    } else {
                        1;
                    }
                } else {
                    if (is_subset($item_marks, $result_marks)) {
                        0;
                    } else {
                        my $result_marks_line = join ",", keys %$result_marks;
                        my $item_marks_line = join ",", keys %$item_marks;
                        confess("Non-subsequent throughs not supported (met [$result_marks_line] vs [$item_marks_line])");
                    }
                }
             }) {
            @result = @{$item};
        }
    }
    return @result;
}

sub is_subset(\%\%) { my ($sub, $super) = @_;
    foreach my $k (keys %$sub) {
        if (!exists $super->{$k}) {
            return 0;
        }
    }
    return 1;
}

# TODO: options parser
# * interactive
# * continue, abort

if ($0 !~ /test\.pl/) {
    main(\@ARGV);
}
