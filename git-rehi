#!/usr/bin/env perl

# vim: foldmethod=marker

use strict;

use Data::Dumper;
use Carp;
use File::Path qw(rmtree);
use File::Temp qw(:mktemp);

my $GIT_DIR = read_popen("git rev-parse --git-dir");
# full list of invalid sylbols is unclear.
# definitely no \ or " (to be used in command-line), what else?
# be safe here
if ($GIT_DIR !~ /^[-a-z0-9_\.,\/ ]+$/i) {
    confess("Some unsupported symbols in: $GIT_DIR");
}

# {{{ utils

sub retry (&$) { my ($code, $ok) = @_;
    my $warray = wantarray;
    while (1) {
        my $result;
        my @result;
        if ($warray) {
            @result = eval { $code->(); }
        } else {
            $result = eval { $code->(); }
        }
        if ($@ ne "") {
            print "Error: $@";
            print "Retry (y/N)?";
            my $answer = <STDIN>;
            if ($answer !~ /^y.*/i) {
                ${$ok} = 0;
                return;
            }
        } else {
            ${$ok} = 1;
            if ($warray) {
                return @result;
            } else {
                return $result;
            }
        }
    }
}

{
    package guard;

    sub new ($&) { my ($class, $sub) = @_;
        return (bless { sub => $sub }, $class);
    }

    sub DESTROY($) { my ($self) = @_;
        $self->{sub}->();
    }
}

# }}}

# {{{ io utils
sub iterate_popen(&$;$) { my ($code, $command, $separator) = @_;
    open(my $in, "-|", $command) or confess "Cannot start a program: $!";
    if (defined $separator) {
        local $/ = $separator;
        while (<$in>) {
            $code->($_);
        }
    } else {
        while (<$in>) {
            $code->($_);
        }
    }
    close ($in) or confess "Program failed";
}

sub iterate_file(&$;$) { my ($code, $filename, $separator) = @_;
    open(my $in, "<", $filename) or confess "Cannot open \"$filename\": $!";
    if (defined $separator) {
        local $/ = $separator;
        while (<$in>) {
            $code->($_);
        }
    } else {
        while (<$in>) {
            $code->($_);
        }
    }
    close ($in);
}
# }}}

# {{{ git utils

sub git_no_uncommitted_changes()
{
    return (system("git diff-index --quiet --ignore-submodules HEAD") == 0);
}

sub git_verify_clean()
{
    die "Not clean working directory\n" unless git_no_uncommitted_changes();
    die "git-am or rebase in progress\n" if -e "$GIT_DIR/rebase-apply";
    die "rebase in progress\n" if -e "$GIT_DIR/rebase-merge";
}

sub git_get_checkedout_branch()
{
    my $head_path = read_popen("git symbolic-ref -q HEAD");
    if ($head_path =~ /refs\/heads\/(.*)/) {
        return $1;
    } else {
        die("Unsupported ref checked-out: $head_path\n");
    }
}

# }}}

# {{{ DOC: Types
#
# $commits = {
#   head => { type => "known_hash", hash => String } | { type => "synced" }
#   refs => { $ref => $hash },
#   marks => { $mark => $hash }.
#   by_hash => { $hash => Entry },
# }
# ref is ahash or symbolic ref
#
# Entry is {
#   ahash => String,
#   hash => String[40],
#   subject => String,
#   parents => [String[40]],
#   tree => String[40],
# }
#
# $todo = [ Step ]
#
# Step is {
#   type => String,
#   ...
# } is {
#   type => one of("pick", "fixup", "edit"),
#   ahash => String
# } or {
#   type => "exec",
#   command => String
# } or {
#   type => "comment",
#   comment => String
# } or {
#   type => "merge",
#   (optional) ahash => String,
#   parents => [String],
#   flags => {
#       (optional) ours => Int,
#       (optional) noff => Int
#   }
# } or {
#   type => "mark"
#   name => String
# } or {
#   type => "reset"
#   ahash => String
# } or {
#   type => "user-comment"
#   content => String
# } or {
#   type => "tail_pick_with_comment"
#   ahash => String
#   message => String
# }
#
# }}}

sub main($) { my ($argv) = @_;
    my $parsed = eval { parse_cli($argv); };
    if ($@ ne "") {
        print STDERR $@;
        return 1;
    }
    if (0) {
    } elsif ($parsed->[0] eq "ABORT") {
        return abort_rebase();
    } elsif ($parsed->[0] eq "CONTINUE") {
        my ($todo, $current, $commits, $target_ref) = restore_rebase();
        if ($current) {
            if (run_continue($current, $commits) != 0) {
                return 1;
            }
            unlink("$GIT_DIR/rehi/current");
        }
        $commits->{head} = { type => "synced" };
        return run_rebase($todo, $commits, $target_ref);
    } elsif ($parsed->[0] eq "SKIP") {
        my ($todo, $current, $commits, $target_ref) = restore_rebase();
        if ($current) {
            run_command("git reset --hard HEAD");
            unlink("$GIT_DIR/rehi/current");
        }
        $commits->{head} = { type => "synced" };
        return run_rebase($todo, $commits, $target_ref);
    } elsif ($parsed->[0] eq "CURRENT") {
        if (-e "$GIT_DIR/rehi/current") {
            print "Current: " . read_file("$GIT_DIR/rehi/current");
        } else {
            die "No rehi in progress\n";
        }
    } elsif ($parsed->[0] eq "RUN") {
        my ($tag, $dest, $source_from_arg, $through, $source_to_arg, $target_arg, $interactive) = @{$parsed};
        git_verify_clean();
        my $initial_branch = git_get_checkedout_branch();
        my $target_ref = do { if ($target_arg ne "") { $target_arg; } else { $initial_branch }};
        my $source_to = do { if ($source_to_arg ne "") { $source_to_arg } else { $target_ref }};
        my $source_from = do {
            if ($source_from_arg ne "") { $source_from_arg }
            elsif ($dest =~ /.*~1$/) { $dest; }
            else { git_merge_base($source_to, $dest); } };
        if ($source_from =~ /^(.*)~1$/) {
            splice @{$through}, 0, 0, $1;
        }
        return main_run($dest, $source_from, $through, $source_to, $target_ref, $initial_branch, $interactive);
    } else {
        confess("Unexpected: " . Data::Dumper($parsed));
    }
}

sub parse_cli($) { my @argv = @{$_[0]};
    my $interactive = 0;
    while (1) {
        if (0) {
        } elsif ($argv[0] eq "-i" || $argv[0] eq "--interactive") {
            $interactive = 1;
            shift @argv;
        } elsif ($argv[0] eq "--abort") { # TODO: make them a very specific
            die("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. (scalar @argv - 1)]) . "\"") if (scalar @argv > 1);
            return ['ABORT'];
        } elsif ($argv[0] eq "--skip") {
            die("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. (scalar @argv - 1)]) . "\"") if (scalar @argv > 1);
            return ['SKIP'];
        } elsif ($argv[0] eq "--continue") {
            die("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. (scalar @argv - 1)]) . "\"") if (scalar @argv > 1);
            return ['CONTINUE'];
        } elsif ($argv[0] eq "--current") {
            die("Extra arguments after " . $argv[0] . ": \"" . join(" ", @argv[1 .. (scalar @argv - 1)]) . "\"") if (scalar @argv > 1);
            return ['CURRENT'];
        } elsif (scalar @argv == 1) {
            return ['RUN', $argv[0], undef, [], undef, undef, $interactive];
        } elsif (scalar @argv == 3 || scalar @argv == 2 && $argv[1] =~ /\.\./) {
            my ($source_from, $through, $source_to) = do {
                my $re_ref0 = qr/(?:[^\.]|(?<!\.)\.)*/;
                my $re_ref1 = qr/(?:[^\.]|(?<!\.)\.)+/;
                my $re_sep = qr/(?<!\.)\.\./;
                if ($argv[1] eq "") {
                    (undef, undef, undef);
                } elsif ($argv[1] =~ /^($re_ref0)$re_sep((?:$re_ref1$re_sep)*)($re_ref0)$/x) {
                    my ($source_from, $source_to) = ($1, $3);
                    my @through_arr = $2 =~ m/($re_ref1)$re_sep/g;
                    ($source_from, \@through_arr, $source_to);
                } else {
                    die("Invalid source spec: $argv[1]");
                }
            };
            return ['RUN', $argv[0], $source_from, $through, $source_to, $argv[2], $interactive];
        } elsif (scalar @argv == 2) {
            return ['RUN', $argv[0], undef, [], undef, $argv[1], $interactive];
        } else {
            die("Invalid arguments: " . join(" ", @argv) . "\n");
        }
    }
}

sub main_run($$$$$$$) { my ($dest, $source_from, $through, $source_to, $target_ref, $initial_branch, $interactive) = @_;
    my ($todo, $commits, $dest_hash) = init_rebase($dest, $source_from, $through, $source_to, $target_ref, $initial_branch);
    if ($interactive) {
        my $ok;
        $todo = add_info_to_todo($todo, $commits);
        $todo = edit_todo($todo, $commits, \$ok);
        if (!$ok) {
            print "Aborted\n";
            cleanup_save();
            return 1;
        }
    }
    if ((grep { $_->{type} ne "user-comment"; } @{$todo}) > 0) {
        $commits->{head} = { type => "known_hash", hash => $dest_hash };
        save_todo($todo, "$GIT_DIR/rehi/todo.backup", $commits);
        run_command("git checkout --quiet --detach $dest_hash");
        return run_rebase($todo, $commits, $target_ref);
    } else {
        print "Nothing to do\n";
        return cleanup_save();
    }
}

sub restore_rebase() {
    my $target_ref = read_file("$GIT_DIR/rehi/target_ref");
    my $commits = git_load_commits();
    # TODO: add $unknown_commits  to $commits
    my $todo = read_todo("$GIT_DIR/rehi/todo", $commits);
    my $current = 0;
    if (-e "$GIT_DIR/rehi/current") {
        $current = get_single(read_todo("$GIT_DIR/rehi/current", $commits));
    }
    return ($todo, $current, $commits, $target_ref);
}

sub init_rebase($$$$$) { my ($dest, $source_from, $through, $source_to, $target_ref, $initial_branch) = @_;
    #print Dumper($dest, $source_from, $source_to, $target_ref);
    #TODO: resolve all arguments
    my ($dest_hash, $source_from_hash, $source_to_hash) = git_resolve_hashes([$dest, $source_from, $source_to]);
    my @through_hashes;
    if (scalar @{$through} > 0) {
        @through_hashes = git_resolve_hashes($through);
    }
    init_save($target_ref, $initial_branch);
    my $commits = git_fetch_cli_commits($source_from, $source_to);
    my $unknown_parents = find_unknown_parents($commits);
    git_fetch_commit_list($commits, $unknown_parents);
    my $todo = build_rebase_sequence($commits, $source_from_hash, $source_to_hash, \@through_hashes);
    # TODO: edit if interactive
    return ($todo, $commits, $dest_hash);
}

sub find_unknown_parents($) { my ($commits) = @_;
    my %result = ();
    foreach my $c (values %{$commits->{by_hash}}) {
        foreach my $p (@{$c->{parents}}) {
            if (!exists $commits->{by_hash}{$p} && !exists $result{$p}) {
                $result{$p} = undef;
            }
        }
    }
    return [keys %result];
}

my $help = "
Commands:

 pick
 fixup
 edit
 exec
 comment
 merge
 :
 reset
 end
";

sub comments_from_string($$) { my ($content, $indent) = @_;
    my @result = map {
        {type=>"user-comment", content => sprintf("%*.s",$indent,"") . $_}
    } (split /\r\n|\n|\r/, $content);

    return (@result);
}

sub add_info_to_todo($$) { my ($old_todo, $commits, $ok) = @_;
    my @new_todo = @$old_todo;
    push @new_todo, comments_from_string($help, 0);
    push @new_todo, {type=>"user-comment", content=>""};
    push @new_todo, {type=>"user-comment", content=>" Commits:"};
    foreach my $step (@$old_todo) {
        if ($step->{type} =~ /^pick|fixup|edit$/ || ($step->{type} eq "merge" && exists $step->{ahash})) {
            if (exists $commits->{refs}{$step->{ahash}} && exists $commits->{by_hash}{$commits->{refs}{$step->{ahash}}}) {
                my $body = $commits->{by_hash}{$commits->{refs}{$step->{ahash}}}{body};
                push @new_todo, comments_from_string("----- " . $step->{ahash} . " -----", 0);
                push @new_todo, comments_from_string($body, 0);
            }
        }
    }
    return \@new_todo;
}

sub edit_todo($$$) { my ($old_todo, $commits, $ok) = @_;
    my ($tmpfh, $tmpname) = mkstemp("$GIT_DIR/rehi/todo.XXXXXXXX");
    # TODO: write without reopen, to fh
    close($tmpfh) or confess ("Unable to close the tmpfile");
    save_todo($old_todo, $tmpname, $commits);
    my $editor = git_sequence_editor();
    my $new_todo =
        retry {
            run_command($editor . " $tmpname");
            # TODO: read unknown commits
            my $todo_rc = read_todo($tmpname, $commits, { onSyntaxError => sub { die(@_, "\n"); } });
            verify_marks($todo_rc);
            $todo_rc;
        } $ok;
    return $new_todo;
}

sub verify_marks($) { my ($todo) = @_;
    my %marks = ();
    my $check = sub ($) {
        if ($_[0] =~ /^\@([0-9a-zA-Z_]+)$/) {
            die "Unknown mark: $1\n" if (!exists $marks{$1});
        }
    };
    foreach my $step (@{$todo}) {
        if ($step->{type} eq "mark") {
            if (exists $marks{$step->{name}}) {
                die "Duplicated mark: $step->{name}\n";
            } else {
                $marks{$step->{name}} = undef;
            }
        } elsif ($step->{type} =~ /^pick|fixup|edit|reset$/) {
            $check->($step->{ahash});
        } elsif ($step->{type} eq "merge") {
            #TODO: verify ahash also, when it's implemented
            foreach my $p (@{$step->{parents}}) {
                $check->($p);
            }
        } elsif ($step->{type} =~ /^comment|exec|user-comment$/) {
        } else {
            confess("Unknown step: $step->{type}");
        }
    }
}

sub run_continue($$) { my ($current, $commits) = @_;
    if (run_command("git rev-parse --verify HEAD >/dev/null"
                . " && git update-index --ignore-submodules --refresh"
                . " && git diff-files --quiet --ignore-submodules", 1) != 0) {
        print "Continue failed - unresolved problems\n";
        return 1;
    }
    # TODO: restore proper rebase-like behavior
    if ($current->{type} eq "pick" || $current->{type} eq "merge") {
        if (git_no_uncommitted_changes()) {
            # commited already
        } else {
            run_command("git commit -c $current->{ahash}");
        }
    } elsif ($current->{type} eq "edit") {
        if (git_no_uncommitted_changes()) {
            # commited already
        } else {
            confess("No unstaged changes should be after 'edit'");
        }
    } elsif ($current->{type} eq "fixup") {
        if (git_no_uncommitted_changes()) {
            # commited already
        } else {
            run_command("git commit --amend");
        }
    } elsif ($current->{type} eq "exec") {
        confess "Cannot continue 'exec $current->{command}'; resolve it manually, then skip or abort";
    } elsif ($current->{type} eq "comment") {
        return comment($current->{comment});
    } else {
        confess "Type $current->{type} is unknown or not implemented";
    }
    return 0;
}

sub run_rebase($$$) { my ($todo, $commits, $target_ref) = @_;
    # TODO: handle errors
    {
        my $g = guard->new(sub {
            eval { sync_head($commits); };
            if ($@ ne "") {
                print "Fatal error while syncing: $@\nContinue not possible\n";
                unlink("$GIT_DIR/rehi/todo");
            }
        });
        while (defined (my $current = shift @{$todo})) {
            my $pause = 0;
            my $has_io = ($current->{type} ne "user-comment");
            if ($has_io) {
                save_todo($todo, "$GIT_DIR/rehi/todo", $commits);
                save_todo([$current], "$GIT_DIR/rehi/current", $commits);
            }
            if (run_step($current, $commits, \$pause) == 0) {
                if ($pause) {
                    return 0;
                }
            } else {
                return 1
            }
            if ($has_io) {
                unlink("$GIT_DIR/rehi/current");
            }
        }
    }
    # TODO: make proper reflog
    run_command("git checkout -B $target_ref");
    return cleanup_save();
}

sub abort_rebase() {
    my $initial_branch = read_file("$GIT_DIR/rehi/initial_branch");
    run_command("git reset --hard $initial_branch");
    run_command("git checkout -f $initial_branch");
    return cleanup_save();
}

sub resolve_ahash($$) { my ($ahash, $commits) = @_;
    if ($ahash =~ /^\@([0-9a-zA-Z_]+)$/) {
        confess("Mark $1 not found") unless exists $commits->{marks}->{$1};
        return $commits->{marks}->{$1};
    } elsif (exists $commits->{refs}->{$ahash}) {
        return $commits->{refs}->{$ahash};
    } else {
        return $ahash;
    }
}

sub run_step($$$) { my ($rebase_step, $commits, $pause) = @_;
    if ($rebase_step->{type} eq "pick") {
        return pick(resolve_ahash($rebase_step->{ahash}, $commits), $commits);
    } elsif ($rebase_step->{type} eq "edit") {
        print "Apply: " . commits_get_subject($commits, $rebase_step->{ahash}) . "\n";
        if (pick(resolve_ahash($rebase_step->{ahash}, $commits), $commits) != 0) {
            return 1;
        }
        sync_head($commits);
        print "Amend the commit and run \"git rehi --continue\"\n";
        ${$pause} = 1;
    } elsif ($rebase_step->{type} eq "fixup") {
        print "Fixup: " . commits_get_subject($commits, $rebase_step->{ahash}). "\n";
        sync_head($commits);
        if (run_command("git cherry-pick --allow-empty --allow-empty-message --no-commit " . resolve_ahash($rebase_step->{ahash}, $commits)
                    . " && git commit --amend --reset-author --no-edit", 1) != 0) {
            print ("Amend by $rebase_step->{ahash} failed. Resolve and --continue or --skip, or --abort\n");
            return 1;
        }
    } elsif ($rebase_step->{type} eq "reset") {
        my $hash_or_ref = resolve_ahash($rebase_step->{ahash}, $commits);
        if (exists $commits->{by_hash}->{$hash_or_ref}) {
            $commits->{head} = { type => "known_hash", hash => $hash_or_ref };
        } else {
            run_command("git reset --hard $hash_or_ref");
            $commits->{head} = { type => "synced" };
        }
    } elsif ($rebase_step->{type} eq "exec") {
        sync_head($commits);
        if (run_command($rebase_step->{command}, 1) != 0) {
            print "Command $rebase_step->{command} failed. Resolve and --continue or --skip, or --abort\n";
            return 1;
        }
    } elsif ($rebase_step->{type} eq "comment") {
        print "Updating comment\n";
        sync_head($commits);
        return comment($rebase_step->{comment});
    } elsif ($rebase_step->{type} eq "mark") {
        my $head_hash = do {
            if ($commits->{head}->{type} eq "known_hash") {
                $commits->{head}->{hash};
            } elsif ($commits->{head}->{type} eq "synced") {
                get_single([git_resolve_hashes(["HEAD"])]);
            } else {
                confess("Unknown head type: $commits->{head}->{type}");
            }
        };
        $commits->{marks}->{$rebase_step->{name}} = $head_hash;
        # TODO: save and restore the head
        my $out;
        open($out, ">>", "$GIT_DIR/rehi/marks")
            and print $out "$rebase_step->{name} $head_hash\n"
            and close($out)
            or confess("Write to \"$GIT_DIR/rehi/marks\" failed: $!");
    } elsif ($rebase_step->{type} eq "merge") {
        return merge($rebase_step, $commits);
    } elsif ($rebase_step->{type} eq "user-comment") {
        return 0;
    } else {
        confess "Type $rebase_step->{type} is unknown or not implemented";
    }
    return 0;
}

sub merge($$) { my ($rebase_step, $commits) = @_;
    #TODO: ahash should be resolved as usual, allowing marks for example
    if ($commits->{head}->{type} eq "known_hash" &&
        exists $rebase_step->{ahash} &&
        exists $commits->{refs}->{$rebase_step->{ahash}} &&
        exists $commits->{by_hash}->{$commits->{refs}->{$rebase_step->{ahash}}})
    {
        my $merge_parents_refs = $rebase_step->{parents};
        my $step_hash = $commits->{refs}->{$rebase_step->{ahash}};
        my $commit_parents = $commits->{by_hash}->{$step_hash}->{parents};
        if (scalar @{$merge_parents_refs} == scalar @{$commit_parents}) {
            my $match = 1;
            for (my $i = 0; $match && $i < @{$merge_parents_refs}; ++$i) {
                if ($merge_parents_refs->[$i] eq "HEAD") {
                    $match = $commits->{head}->{hash} eq $commit_parents->[$i];
                } else {
                    my $resolved = resolve_ahash($merge_parents_refs->[$i], $commits);
                    if ($resolved eq $commit_parents->[$i]) {
                        $match = 1;
                    } elsif ($resolved =~ /^[0-9a-zA-Z_]+$/ && (substr $commit_parents->[$i], 0, length $resolved) eq $resolved) {
                        # cheating here; $commits should have been known about it if I implement them properly
                        $match = 1;
                    } else {
                        $match = 0;
                    }
                }
            }
            if ($match) {
                print "Fast-forwarding unchanged merge: $rebase_step->{ahash} $commits->{by_hash}->{$step_hash}->{subject}\n";
                $commits->{head}->{hash} = $step_hash;
                return 0;
            }
        }
    }
    return merge_new($rebase_step, $commits);
}

sub merge_new($$) { my ($rebase_step, $commits) = @_;
    sync_head($commits);
    print "Merging\n";
    # to merge as non-first child:
    # 1. get the current position
    # 2. reset to the first child
    my $command = "git merge";
    if (exists $rebase_step->{ahash}) {
        $command .= " --no-commit";
    } else {
        $command .= " --no-edit";
    }
    if ($rebase_step->{flags}->{ours}) {
        $command .= " --strategy=ours";
    }
    if ($rebase_step->{flags}->{noff}) {
        $command .= " --no-ff";
    }
    my @parents = map { resolve_ahash($_, $commits) } @{$rebase_step->{parents}};
    my %parent_hashes = map { $_ => undef } git_resolve_hashes(\@parents);
    my $head_pos = find_only("HEAD", \@parents);
    if ($head_pos != 0) {
        # TODO: how to handle it in skip?
        # TODO: dont forget to make sure all parents are good cli args
        ($parents[$head_pos]) = git_resolve_hashes(["HEAD"]);
        run_command("git reset --hard $parents[0]");
    }
    shift @parents;
    foreach my $p (@parents) {
        $command .= " $p";
    }
    if (run_command($command, 1) != 0) {
        print "Merge failed. Resolve and --continue or --skip, or --abort\n";
        return 1;
    }
    if (exists $rebase_step->{ahash}) {
        if (run_command("git commit -C " . resolve_ahash($rebase_step->{ahash}, $commits) . " --reset-author", 1) != 0) {
            print "Merge commit failed, fastforward?\n";
            print "You would probably want to do now one of the following:\n";
            print " * force non-fastforward merge\n";
            print " * merge some other parent instead of the one from history\n";
            print " * skip the step at all (is it a non-interactive rebase?)\n";
            print "Then invoke git rehi --skip\n";
            return 1;
        }
    }
    return 0;
}

sub find_only ($\@) { my ($needle, $items) = @_;
    my $result = -1;
    my $pos = 0;
    foreach my $item (@{$items}) {
        if ($item eq $needle) {
            if ($result != -1) {
                confess("Duplicated $needle");
            } else {
                $result = $pos;
            }
        }
        ++$pos;
    }
    if ($result == -1) {
        confess("Not found: $needle");
    }
    return $result;
}

sub sync_head($) { my ($commits) = @_;
    if ($commits->{head}->{type} eq "known_hash") {
        run_command("git reset --hard $commits->{head}->{hash}");
        $commits->{head} = { type => "synced" };
    } elsif ($commits->{head}->{type} eq "synced") {
        # nothing to do
    } else {
        confess("Unknown head type: $commits->{head}->{type}");
    }
}

sub pick($$) { my ($hash, $commits) = @_;
    if ($commits->{head}->{type} eq "known_hash") {
        if (exists $commits->{by_hash}->{$hash} &&
            scalar @{$commits->{by_hash}->{$hash}->{parents}} == 1 &&
            scalar $commits->{by_hash}->{$hash}->{parents}->[0] eq $commits->{head}->{hash}) {
            print "Fast-forwarding unchanged commit: $commits->{by_hash}->{$hash}->{ahash} $commits->{by_hash}->{$hash}->{subject}\n";
            $commits->{head}->{hash} = $hash;
            return 0;
        } else {
            print "Apply: $hash " . ((exists $commits->{by_hash}->{$hash}) ? $commits->{by_hash}->{$hash}->{subject} : "???") . "\n";
            sync_head($commits);
        }
    } elsif ($commits->{head}->{type} eq "synced") {
    } else {
        confess("Unknown head type: $commits->{head}->{type}");
    }
    if (run_command("git cherry-pick --allow-empty --allow-empty-message --ff $hash", 1) != 0) {
        print "Pick $hash failed. Resolve and --continue or --skip, or --abort\n";
        return 1;
    }
    return 0;
}

sub comment($) { my ($comment) = @_;
    write_file("$GIT_DIR/rehi/commit_msg", $comment);
    if (run_command("git commit --amend -F \"$GIT_DIR/rehi/commit_msg\"", 1) != 0) {
        print "Editing comment failed. Resolve and --continue or --skip, or --abort\n";
    }
}

sub build_rebase_sequence($$$$) { my ($commits, $from, $to, $through) = @_;
    my @result;
    my $prev_hash = $from;
    my $sequence = find_sequence($commits->{by_hash}, $from, $to, $through);
    my %marks = ( $from => undef );
    @marks{@{$sequence}} = ();
    my $mark_num = 1;
    foreach my $step_hash (@{$sequence}) {
        foreach my $parent (grep { $_ ne $prev_hash; } @{$commits->{by_hash}->{$step_hash}->{parents}}) {
            if (exists $marks{$parent} && !defined $marks{$parent}) {
                $marks{$parent} = "tmp_" . $mark_num;
                $mark_num++;
            }
        }
        $prev_hash = $step_hash;
    }
    if (defined $marks{$from}) {
        push @result, { type => 'mark', name => $marks{$from} };
    }
    my $prev_hash = $from;
    foreach my $step_hash (@{$sequence}) {
        if (!grep { $_ eq $prev_hash; } @{$commits->{by_hash}->{$step_hash}->{parents}}) {
            foreach my $new_prev (grep { exists $marks{$_}; } @{$commits->{by_hash}->{$step_hash}->{parents}}) {
                confess ("Unresolved mark for $new_prev") if (!defined $marks{$new_prev});
                push @result, { type => "reset", ahash => "\@$marks{$new_prev}" };
                $prev_hash = $new_prev;
                last;
            }
        }
        if (scalar @{$commits->{by_hash}->{$step_hash}->{parents}} == 1) {
            push @result, { type => 'pick', ahash => $commits->{by_hash}->{$step_hash}->{ahash} };
        } else {
            push @result, make_merge_steps($step_hash, $prev_hash, $commits, \%marks);
        }
        if (defined $marks{$step_hash}) {
            push @result, { type => 'mark', name => $marks{$step_hash} };
        }
        $prev_hash = $step_hash;
    }
    return \@result;
}

# TODO: tests, tests, tests
sub make_merge_steps($$$$) { my ($step_hash, $prev_hash, $commits, $marks) = @_;
    find_only($prev_hash, @{$commits->{by_hash}->{$step_hash}->{parents}});
    my @parents_ahashes = map {
        if ($_ eq $prev_hash) {
            "HEAD";
        } elsif (exists $marks->{$_}) {
            confess ("Unresolved mark for $_") if (!defined $marks->{$_});
            "\@$marks->{$_}";
        } elsif (exists $commits->{by_hash}->{$_}) {
            $commits->{by_hash}->{$_}->{ahash};
        } else {
            confess("Unknown parent: $_");
        }
    } @{$commits->{by_hash}->{$step_hash}->{parents}};
    my %merge_flags;
    if ($commits->{by_hash}{$step_hash}{tree} eq $commits->{by_hash}{$commits->{by_hash}{$step_hash}{parents}[0]}{tree}) {
        $merge_flags{ours} = 1;
    }
    my $ahash = $commits->{by_hash}->{$step_hash}->{ahash};
    return { type => "merge", ahash => $ahash, parents => \@parents_ahashes, flags => \%merge_flags };
}

sub git_resolve_hashes($) { my ($refs) = @_;
    foreach (@{$refs}) { verify_cmdarg($_); }
    my $refs_str = join " ", @{$refs};
    my @result = ();
    iterate_popen {
        s/^\s+|\s+$//g;
        push @result, $_;
    } "git rev-parse $refs_str";
    confess("Hash number does not match") unless (scalar @result == scalar @{$refs});
    return @result;
}

sub git_fetch_cli_commits($$) { my ($from, $to) = @_;
    verify_cmdarg($from);
    verify_cmdarg($to);
    my $commits = {by_hash => {}, refs => {}, marks => {}};
    git_fetch_commits($commits, "git log -z --ancestry-path --pretty=format:%H:%h:%T:%P:%B $from..$to");
    return $commits;
}

sub git_fetch_commit_list($$) { my ($commits, $unknowns_arg) = @_;
    my @unknowns = @{$unknowns_arg};
    while (scalar @unknowns > 0) {
        my @chunk = splice @unknowns, 0, 20;
        my $command = "git show -z --no-patch --pretty=format:%H:%h:%T:%P:%B";
        foreach my $c (@chunk) {
            verify_cmdarg($c);
            $command .= " $c";
        }
        git_fetch_commits($commits, $command);
    }
}

sub git_fetch_commits($$) { my ($commits, $command) = @_;
    open(my $in, ">>", "$GIT_DIR/rehi/commits") or confess("Cannot write commits cache ($GIT_DIR/rehi/commits): $!");
    iterate_popen {
        if ($_ ne "\n") {
            git_parse_commit_line($commits, $_);
            printf($in "%s", $_) or confess("Cannot write commits cache ($GIT_DIR/rehi/commits): $!");
        }
    } $command, v000;
    close($in) or confess("Cannot write commits cache ($GIT_DIR/rehi/commits): $!");
    return $commits;
}

sub git_load_commits() {
    my $commits = {by_hash => {}, refs => {}, marks => {}};
    iterate_file { git_parse_commit_line($commits, $_); } "$GIT_DIR/rehi/commits", v000;
    if (-e "$GIT_DIR/rehi/marks") {
        iterate_file {
            if (/^([0-9a-zA-Z_\/]+) ([0-9a-fA-F]+)$/) {
                $commits->{marks}->{$1} = $2;
            } else {
                confess("Invalid mark line: $_");
            }
        } "$GIT_DIR/rehi/marks";
    }
    return $commits;
}

sub git_parse_commit_line($$) { my ($commits, $line) = @_;
    if ($line =~ /^([0-9a-f]+):([0-9a-f]+):([0-9a-f]+):([0-9a-f ]*):(.*)$/s) {
        my $hash = $1;
        my $ahash = $2;
        my $tree = $3;
        my @parents = split(/ /, $4);
        my $body = $5;
        chomp($body);
        my $body_lines = [split(/\r|\n/, $body)];
        my $subject = $body_lines->[0];
        verify_hash($hash);
        foreach my $p (@parents) { verify_hash($p); }
        if (!exists $commits->{by_hash}->{$hash}) {
            my $obj = {parents => \@parents, subject => $subject, hash => $hash, ahash => $ahash, tree => $tree, body => $body};
            $commits->{by_hash}->{$hash} = $obj;
        }
        if (exists $commits->{refs}->{$ahash}) {
            if ($commits->{refs}->{$ahash} ne $hash) {
                confess("duplicated ref with different hash: $ahash => $hash, $commits->{refs}->{$ahash}");
            }
        } else {
            $commits->{refs}->{$ahash} = $hash;
        }
    } else {
        confess("Could not parse line: $line");
    }
}

sub git_merge_base($$) { my ($b1, $b2) = @_;
    verify_cmdarg($b1);
    verify_cmdarg($b2);
    my $result = "";
    my $hit = 0;
    iterate_popen {
        s/^\s+|\s+$//g;
        if (!$hit) {
            $result = $_;
            $hit = 1;
        } else {
            confess "Multiple merge-bases for $b1 and $b2";
        }
    } "git merge-base -a $b1 $b2";
    if (!$hit) {
        confess "Merge-base not found for $b1 and $b2"
    }
    return $result;
}

sub git_sequence_editor() {
    if (exists $ENV{GIT_SEQUENCE_EDITOR}) {
        return $ENV{GIT_SEQUENCE_EDITOR};
    }

    foreach my $cmd ("git config sequence.editor || true", "git var GIT_EDITOR || true") {
        my $git_editor = read_popen($cmd);
        if ($git_editor ne "") {
            return $git_editor;
        }
    }

    confess ("Editor not found");
}

sub run_command($;$) { my ($command) = @_;
    my $ret = system($command);
    if ($ret == 0) {
        return 0;
    } elsif (scalar @_ > 1 && $_[1] != 0) {
        return 1;
    } else {
        confess("Command failed: $ret") unless ($ret == 0);
    }
}

sub read_popen($) { my ($command) = @_;
    local $_;
    my $res = "";
    iterate_popen { $res .= $_; } $command;
    $res =~ s/^\s+|\s+$//g;
    return $res;
}

sub verify_hash($) { my ($str) = @_;
    # allow abbreviated
    if ($str !~ /^[0-9a-f]{40}$/) {
        confess "Invalid hash: $str";
    }
}

sub verify_cmdarg($) { my ($str) = @_;
    if ($str =~ /["'\\\(\)#]|[\x00- ]/) {
        confess "Invalid cmdarg: $str";
    }
}

sub init_save($$) { my ($target_ref, $initial_branch) = @_;
    if (-e "$GIT_DIR/rehi") {
        confess "already in progress?";
    }
    mkdir("$GIT_DIR/rehi") or confess "Mkdir $GIT_DIR/rehi failed: $!";
    write_file("$GIT_DIR/rehi/target_ref", $target_ref);
    write_file("$GIT_DIR/rehi/initial_branch", $initial_branch);
}

sub cleanup_save() {
    # will throw itself
    if (-e "$GIT_DIR/rehi") {
        if (-e "$GIT_DIR/rehi/todo.backup") {
            run_command("cp -f $GIT_DIR/rehi/todo.backup $GIT_DIR/rehi_todo.backup");
        }
        return ((rmtree("$GIT_DIR/rehi") > 0) ? 0 : 1);
    } else {
        return 0;
    }
}

sub commits_get_subject($$) { my ($commits, $ref) = @_;
    # TODO: not existing keys be assertions as soon as reading of unknown commits is imlemented
    if (!exists $commits->{refs}->{$ref}) {
        return "???";
    }
    my $hash = $commits->{refs}->{$ref};
    if (!exists $commits->{by_hash}->{$hash}) {
        return "???";
    }
    return $commits->{by_hash}->{$hash}->{subject};
}

sub save_todo($$$) { my ($todo, $file, $commits) = @_;
    my @colllect_main = ();
    my @colllect_tail = ();
    my $tail = 1;
    foreach my $step (reverse @{$todo}) {
        if ($tail) {
            if ($step->{type} eq "user-comment" || $step->{type} eq "tail_pick_with_comment") {
                push @colllect_tail, $step;
            } else {
                $tail = 0;
                push @colllect_main, $step;
            }
        } else {
            push @colllect_main, $step;
        }
    }
    my @main = reverse @colllect_main;
    my @tail = reverse @colllect_tail;
    with_output_file($file, sub { my ($out) = @_;
        foreach my $step (@main) {
            if ($step->{type} eq "pick") {
                print $out "pick $step->{ahash} " . commits_get_subject($commits, $step->{ahash}) . "\n";
            } elsif ($step->{type} eq "edit") {
                print $out "edit $step->{ahash} " . commits_get_subject($commits, $step->{ahash}) . "\n";
            } elsif ($step->{type} eq "fixup") {
                print $out "fixup $step->{ahash} " . commits_get_subject($commits, $step->{ahash}) . "\n";
            } elsif ($step->{type} eq "reset") {
                print $out "reset $step->{ahash}\n";
            } elsif ($step->{type} eq "exec") {
                if ($step->{command} =~ /\n/) {
                    confess "multiline command cannot be saved";
                }
                print $out "exec $step->{command}\n";
            } elsif ($step->{type} eq "comment") {
                write_todo_comment($out, $step->{comment});
            } elsif ($step->{type} eq "merge") {
                my $flags_str = "";
                if ($step->{flags}->{ours}) {
                    $flags_str .= " --ours"
                }
                if ($step->{flags}->{noff}) {
                    $flags_str .= " --no-ff"
                }
                my $parents_str2 = join ",", @{$step->{parents}};
                my $subject = "";
                if (exists $step->{ahash}) {
                    $flags_str .= " -c $step->{ahash}";
                    $subject = " " . commits_get_subject($commits, $step->{ahash});
                }
                print $out "merge$flags_str $parents_str2$subject\n";
            } elsif ($step->{type} eq "mark") {
                print $out ": $step->{name}\n";
            } elsif ($step->{type} eq "user-comment") {
                print $out "# $step->{content}\n";
            } else {
                confess "Type $step->{type} is unknown or not allowed for main section of todo";
            }
        }
        if (scalar @tail > 0) {
            print $out "end\n";
            foreach my $step (@tail) {
                if ($step->{type} eq "user-comment") {
                    print $out "$step->{content}\n";
                } elsif ($step->{type} eq "tail_pick_with_comment") {
                    print $out "----- $step->{ahash} ----- \n";
                    write_todo_comment($out, $step->{message});
                }
            }
        }
    });
}

sub write_todo_comment($$) { my ($out, $comment) = @_;
    if ($comment =~ /^\.$/m || $comment =~ /[^\n]\z/s || $comment =~ /^#/m) {
        write_todo_comment_quoted($out, $comment);
    } else {
        write_todo_comment_plain($out, $comment);
    }
}

sub write_todo_comment_quoted($$) { my ($out, $comment) = @_;
    my $quote_end = '}}}';
    while ($comment =~ /\Q$quote_end\E/) {
        $quote_end = $quote_end . '}';
    }
    my $quote_end_reverted = $quote_end;
    $quote_end_reverted =~ tr/}/{/;
    print $out ("comment " . $quote_end_reverted . "\n" . $comment . $quote_end . "\n");
}

sub write_todo_comment_plain($$) { my ($out, $comment) = @_;
    print $out "comment\n";
    while ($comment =~ /\n\.\n/) {
        $comment =~ s/\n\.\n/\n/;
    }
    print $out "$comment";
    if (substr($comment, -1) ne "\n") {
        print $out "\n";
    }
    print $out ".\n";
}

sub default_error($) { my ($msg) = @_;
    confess($msg);
}

# TODO for caching refs
# * add to commits aliases (refs, whatever), which map entered aliases to commits
# * save and restore them to something like rehi/commit_refs
# * refer to the refs dictionary in read_todo()
# * fill missing refs and missing commits in the following function
# * consider splitting the resolving part; I believe it should be possible to handle all state in todo+commits
#   * describe the data structure
# * use git_resolve_hashes() for resolving refs, git show ... for getting info

sub read_todo($$;\$) { my ($filename, $commits, $errorHandler) = @_;
    my $onSyntaxError = (defined $errorHandler && exists $errorHandler->{onSyntaxError}) ? $errorHandler->{onSyntaxError} : \&default_error ;
    my $todo = [];
    open(my $in, "<", $filename) or confess "Cannot open file $filename: $!";
    my $mode = "COMMAND";
    my $comment = undef;
    my $quote_end = "";
    while (<$in>) {
        if ($mode eq "COMMAND") {
            if (/^# ?([^\r\n]*)[\r\n]*$/) {
                push @{$todo}, {type => "user-comment", content => $1};
            } elsif (/^end$/) {
                $mode = "DONE";
            } elsif (/^(f|fixup) (\@?[0-9a-zA-Z_\/]+)( (.*))?$/) {
                push @{$todo}, {type => "fixup", ahash => $2};
            } elsif (/^(p|pick) (\@?[0-9a-zA-Z_\/]+)( (.*))?$/) {
                push @{$todo}, {type => "pick", ahash => $2};
            } elsif (/^(e|edit) (\@?[0-9a-zA-Z_\/]+)( (.*))?$/) {
                push @{$todo}, {type => "edit", ahash => $2};
            } elsif (/^(reset) (\@?[0-9a-zA-Z_\/]+)?$/) {
                push @{$todo}, {type => "reset", ahash => $2};
            } elsif (/^(x|exec) (.+)$/) {
                push @{$todo}, {type => "exec", command => $2};
            } elsif (/^comment$/) {
                $mode = "COMMENT_PLAIN";
                $comment = "";
            } elsif (/^comment ([\<\{\[\(]+)$/) {
                $mode = "COMMENT_QUOTED";
                $comment = "";
                my $quote_end_tmp = $1;
                $quote_end_tmp =~ tr/<{[(/>}])/;
                $quote_end = $quote_end_tmp;
            } elsif (/^merge(( --ours| --no-ff| -c \@?[0-9a-zA-Z_\/]+)*) (.+[^\n\r ])$/) {
                my $pos_string = $3;
                # TODO: verify as refs
                my $ahash = undef;
                my $flags = {};
                my @options = split / +/,$1;
                if ($options[0] eq "") {
                    shift @options;
                }
                while (scalar @options > 0) {
                    if ($options[0] eq "--ours") {
                        shift @options;
                        $flags->{ours} = 1;
                    } elsif ($options[0] eq "--no-ff") {
                        shift @options;
                        $flags->{noff} = 1;
                    } elsif (scalar @options > 1 && $options[0] eq "-c") {
                        shift @options;
                        $ahash = shift @options;
                    } else {
                        $onSyntaxError->("Unexpected merge options: " . Dumper([@options]));
                    }
                }
                my @pos_args = split / +/, $pos_string, 2;
                my $parents = [split /,/, $pos_args[0]];
                my $step = {type => "merge", parents => $parents, flags => $flags};
                if (defined $ahash) {
                    $step->{ahash} = $ahash;
                }
                push @{$todo}, $step;
            } elsif (/^: ([^\n\r ]+)$/) {
                my $name = $1;
                if ($name =~ /[^0-9a-z_]/i) {
                    $onSyntaxError->("Dangerous symbols in mark name: $name");
                }
                push @{$todo}, {type => "mark", name => $name};
            } elsif (/^[[:space:]]*$/) {
            } else {
                s/\n//;
                $onSyntaxError->("Unrecognised todo line for mode $mode: \"$_\"");
            }
        } elsif ($mode eq "COMMENT_PLAIN") {
            if (/^# ?([^\r\n]*)[\r\n]*$/) {
                push @{$todo}, {type => "user-comment", content => $1};
            } elsif (/^\.$/) {
                $mode = "COMMAND";
                push @{$todo}, {type => "comment", comment => $comment};
            } else {
                $comment = $comment . $_;
            }
        } elsif ($mode eq "COMMENT_QUOTED") {
            if (/^(.*)\Q$quote_end\E$/) {
                $mode = "COMMAND";
                $comment = $comment . $1;
                push @{$todo}, {type => "comment", comment => $comment};
            } else {
                $comment = $comment . $_;
            }
        } elsif ($mode eq "DONE") {
            if (/^(.*)$/) {
                push @{$todo}, {type => "user-comment", content => $1};
            } else {
                $onSyntaxError->("Impossible, line=\"$_\"");
            }
        } else {
            $onSyntaxError->("Unexpected mode: $mode");
        }
    }
    close($in);
    if ($mode ne "COMMAND" && $mode ne "DONE") {
        $onSyntaxError->("Unterminated comment");
    }
    # TODO: resolve the $unknown_commits
    return $todo;
}

sub with_output_file($$) { my ($filename, $proc) = @_;
    if (ref $filename eq "") {
        open(my $out, ">", $filename . ".new") or confess "Cannot open file $filename.new: $!";
        $proc->($out);
        close($out) or confess "Cannot close output file $filename.new: $!";
        rename($filename . ".new", $filename) or "Cannot replace output file $filename: $!";
    } else {
        # for testing
        open(my $out, ">", $filename) or confess "Cannot open file $filename: $!";
        $proc->($out);
        close($out) or confess "Cannot close output file $filename.new: $!";
    }
}

sub write_file($$) { my ($filename, $str) = @_;
    with_output_file($filename, sub { my ($out) = @_;
        print $out $str;
    });
}

sub read_file($) { my ($filename) = @_;
    open(my $out, "<", $filename) or confess "Cannot open file $filename: $!";
    my $data = "";
    if (read($out, $data, 1024) <= 0) {
        confess "Read failed: $!";
    }
    close($out) or confess "Cannot close file $filename: $!";
    return $data;
}

sub get_single(\@) { my ($array) = @_;
    if (scalar @{$array} != 1) {
        confess ("Should be an array with single element: " . Dumper($array));
    }
    return $array->[0];
}


# $commits : { $hash => { parents => [ $hash ] } }
# returns: [ $hash ]
sub find_sequence($$$$) { my ($commits, $from, $to, $through_list) = @_;
    # deep-first search, coroutine-based approach
    # fun X($v)
    #  do in loop:
    #   if $v == $from - stop and return the sequence (**)
    #   if 0 parents - stop
    #   if >1 children - pause and wait until all children are processed.
    #    add their output to the end of the sequence and continue
    #   if >1 children and you are not 1st - mark the children you came by as processed and store your sequence (*), then stop
    #   otherwise add the current to sequence
    #   fork itself for each parent, continuing the sequence
    # (*) store only the portion which is not yet in the sequence. Looks like it should be enough just to filter it
    # (**) here several returns should be sorted out

    # thread info:
    # { state => "READY" | "WAIT_CHILDREN" | "DONE" | "FINALIZE_MERGEBASES",
    #   current => String,
    #   todo => [ String ] }
    # copied while forking
    # children_waiters = { $hash => { todo_index => { String => () }, left => num, thread => ref to thread } }
    # children_num => { $hash => num }
    # terminating_commits = { $hash => undef }

    my %children_num = ();
    foreach my $h (keys %{$commits}) {
        $children_num{$h} = 0;
    }
    $children_num{$from} = 0;
    $children_num{$to} = 0;
    # fill children_total for each commit
    foreach my $h (keys %{$commits}) {
        if(exists $commits->{$h}->{parents}) {
            foreach my $p (@{$commits->{$h}->{parents}}) {
                if (exists $children_num{$p}) {
                    $children_num{$p}++;
                } else {
                    $children_num{$p} = 1;
                }
            }
        }
    }
    my %children_waiters = ();
    my @schedule = ({ state => "READY", current => $to, todo => []});
    my %terminating_commits = ();

    # FIXME: very slow, just to make it work
    # non-branching regions should be recorded without recreating
    # TODO: case of throughs in several branches is not covered
    while (scalar @schedule > 0 && $schedule[0]->{state} ne "DONE") {
        my $i = 0;
        while ($schedule[$i]->{state} ne "READY" && $schedule[$i]->{state} ne "FINALIZE_MERGEBASES") {
            ++$i;
            confess("No thread is READY") if ($i >= scalar @schedule);
        }

        my $hash = $schedule[$i]->{current};
        if (exists $terminating_commits{$hash}) {
            splice @schedule, $i, 1;
        } elsif ($schedule[$i]->{state} eq "FINALIZE_MERGEBASES") {
            if ($children_num{$hash} > 1) {
                if (exists $children_waiters{$hash}) {
                    $children_waiters{$hash}{thread}{state} = "FINALIZE_MERGEBASES";
                }
            }
            $terminating_commits{$hash} = ();
            my @new_tasks = map {
                { state => "FINALIZE_MERGEBASES", current => $_ };
            } ((exists $commits->{$hash}) ? @{$commits->{$hash}->{parents}} : ());
            splice @schedule, $i, 1, @new_tasks;
        } elsif ($hash eq $from) {
            $schedule[$i]->{state} = "DONE";
            my %todo_index = ();
            @todo_index{@{$schedule[$i]->{todo}}} = ();
            if ((grep { !exists $todo_index{$_}; } @{$through_list}) > 0) {
                splice @schedule, $i, 1, ();
            } else {
                ++$i;
            }
            my @new_tasks = map {
                { state => "FINALIZE_MERGEBASES", current => $_ };
            } ((exists $commits->{$hash}) ? @{$commits->{$hash}->{parents}} : ());
            splice @schedule, $i, 0, @new_tasks;
        } elsif ($children_num{$hash} > 1 && (!exists $children_waiters{$hash} || $children_waiters{$hash}->{left} > 0)) {
            if (exists $children_waiters{$hash}) {
                foreach my $step (@{$schedule[$i]->{todo}}) {
                    if (!exists $children_waiters{$hash}->{todo_index}->{$step}) {
                        push @{$children_waiters{$hash}->{thread}->{todo}}, $step;
                        $children_waiters{$hash}->{todo_index}->{$step} = undef;
                    }
                }
                $children_waiters{$hash}->{left}--;
                if ($children_waiters{$hash}->{left} == 0) {
                    $children_waiters{$hash}->{thread}->{state} = "READY";
                }
                splice @schedule, $i, 1, ();
            } else {
                my %todo_index = ();
                @todo_index{@{$schedule[$i]->{todo}}} = ();
                $children_waiters{$hash} = { todo_index => \%todo_index,
                                              left => $children_num{$hash} - 1,
                                              thread => $schedule[$i] };
                $schedule[$i]->{state} = "WAIT_CHILDREN";
            }
        } else {
            push @{$schedule[$i]->{todo}}, $hash;
            my @new_tasks = map {
                { state => "READY", current => $_, todo => [ @{$schedule[$i]->{todo}} ] };
            } ((exists $commits->{$hash}) ? @{$commits->{$hash}->{parents}} : ());
            splice @schedule, $i, 1, @new_tasks;
        }
    }

    if (scalar @schedule > 0) {
        return [ reverse @{$schedule[0]->{todo}} ];
    } else {
        confess("No path found");
    }
}

# TODO: options parser
# * interactive
# * continue, abort

if ($0 !~ /test\.pl/) {
    eval { exit(main(\@ARGV)); };
    if ($@ ne "") {
        print STDERR "Error: $@";
        exit(1);
    }
}
